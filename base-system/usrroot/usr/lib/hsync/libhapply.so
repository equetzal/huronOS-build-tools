#!/bin/bash

#	libhapply.sh (hsync.sh library)
#	This library contains functions to apply the directives to the
#	system such as configurations, software or preferences.
#
#	Copyright (C) 2022, huronOS Project:
#		<http://huronos.org>
#
#	Licensed under the GNU GPL Version 2
#		<http://www.gnu.org/licenses/gpl-2.0.html>
#
#	Authors:
#		Enya Quetzalli <equetzal@huronos.org>
#		Abraham Omar   <aomm@huronos.org>

apply_directives_to_system() {

	## Select between default directives and custom ones
	select_directives_to_use
	## Select the mode that will be applied
	select_mode_to_apply

	## Only change the persistence disk if clock is in sync so that we're sure that
	#  is time to change the disk.
	if [ "$STATE_IS_CLOCK_SYNC" = "yes" ]; then
		## Change the persistent partition
		apply_persistence_mode
	fi
	apply_global_directives
	apply_specific_directives

	## Update the new state
	update_state
	# When the current time reaches it end or other mode
	# should interrupt current mode, force the execution
	# of this function even if the directives file have
	# not changed.
	schedule_next_mode_change

	return 0
}

apply_global_directives() {

	log "Applying [Global] directives"
	set_timezone
	set_keyboards
	set_current_keyboard

	return 0 # success
}

# $1 = Section name of specific directives
apply_specific_directives() {

	case $NEW_MODE in
	"always") DIRECTIVES_SPECIFIC_CONFIG="Always" ;;
	"event") DIRECTIVES_SPECIFIC_CONFIG="Event" ;;
	"contest") DIRECTIVES_SPECIFIC_CONFIG="Contest" ;;
	esac

	set_network_filters
	set_hmount_rules
	set_software
	set_bookmarks
	systemctl start "happly-wallpaper@$DIRECTIVES_SPECIFIC_CONFIG.service"
	rfkill unblock bluetooth

	return 0 # success
}

select_directives_to_use() {
	DIRECTIVES_FILE_TO_USE=$DIRECTIVES_FILE
	if directives_already_expired "$DIRECTIVES_FILE"; then
		log "-The directives file is already expired, using default directives."
		DIRECTIVES_FILE_TO_USE=$DIRECTIVES_DEFAULT
	fi

	log " Directives file contents:\n$(cat "$DIRECTIVES_FILE")\n"

	return 0 # sucess
}

## Function to return the value of a given variable
# $1 = Section
# $2 = Variable name
get_directives_var() {
	declare SECTION="$1"
	declare VAR="$2"
	sed -nE "/^\[$SECTION\]$/{:l n;/^(\[.*\])?$/q;p;bl}" "$DIRECTIVES_FILE_TO_USE" | grep "$VAR" | cut -d= -f2
}

## Function to return the times of a event or contest
# $1 = Times Section
get_directives_times() {
	declare SECTION="$1"
	sed -nE "/^\[$SECTION\]$/{:l n;/^(\[.*\])?$/q;p;bl}" "$DIRECTIVES_FILE_TO_USE"
}

update_next_apply() {
	CURRENT_TIME=$(date +'%s')
	INTERESTING_TIME=$(date --date "$1" +'%s')

	## Check if interesting_time happens after now and earlier than previous NEXT_APPLY
	if [ "$CURRENT_TIME" -lt "$INTERESTING_TIME" ]; then
		if [ ! "$EXECUTION_NEXT_SCHEDULED_APPLY_TIME" ]; then
			EXECUTION_NEXT_SCHEDULED_APPLY_TIME=$INTERESTING_TIME
		elif [ "$EXECUTION_NEXT_SCHEDULED_APPLY_TIME" -gt "$INTERESTING_TIME" ]; then
			EXECUTION_NEXT_SCHEDULED_APPLY_TIME=$INTERESTING_TIME
		fi
	fi
}

select_mode_to_apply() {

	## If the clock is not in sync, hardware clock might not match directives time
	#  so we need to wait until clock is sync to re-apply directives. In the meanwhile,
	#  we should asume that state stills the same as last time shutdown.
	if system_has_just_booted && [ "$STATE_IS_CLOCK_SYNC" = "no" ]; then
		NEW_MODE="$STATE_MODE"
		NEW_MODE_START_TIME_UTC="$STATE_MODE_START_TIME_UTC"
		NEW_MODE_END_TIME_UTC="$STATE_MODE_END_TIME_UTC"
		log "Skipping mode selection due to unsync system clock."
		return 0 #Success
	fi

	# Modes have priority set to -Always < Event < Contest-, so
	# we will assume mode is Always unless a higher priority mode
	# overrides the new mode.
	NEW_MODE="always"
	NEW_MODE_START_TIME_UTC=""
	NEW_MODE_END_TIME_UTC=""

	## Declare some variables
	local TIMES START END START_SECONDS END_SECONDS
	HAS_EVENT_CONFIG="$(get_directives_var "Global" "EventConfig")"
	HAS_CONTEST_CONFIG="$(get_directives_var "Global" "ContestConfig")"
	TIMEZONE="$(get_directives_var "Global" "TimeZone")"
	CURRENT_TIME_SECONDS="$(date +'%s')"

	## Check for event mode, and override NEW_MODE if it is running
	if [ "$HAS_EVENT_CONFIG" = "true" ]; then
		TIMES="$(get_directives_times "Event-Times")"
		log "Reading [Event-Times]:
		$TIMES"

		# For each start-time and end-time, check if we're in between.
		while read -r START END; do
			START_SECONDS=$(date --date="TZ=\"$TIMEZONE\" $START" +'%s')
			END_SECONDS=$(date --date="TZ=\"$TIMEZONE\" $END" +'%s')
			if [ "$CURRENT_TIME_SECONDS" -ge "$START_SECONDS" ] &&
				[ "$CURRENT_TIME_SECONDS" -lt "$END_SECONDS" ]; then
				NEW_MODE="event"
				NEW_MODE_START_TIME_UTC=$(date --utc --iso-8601="seconds" --date="@$START_SECONDS")
				NEW_MODE_END_TIME_UTC=$(date --utc --iso-8601="seconds" --date="@$END_SECONDS")
			fi
			update_next_apply "$START"
			update_next_apply "$END"
		done < <(echo "$TIMES" | xargs -n 2)
	fi

	## Check for event mode, and override NEW_MODE if it is running
	if [ "$HAS_CONTEST_CONFIG" = "true" ]; then
		TIMES="$(get_directives_times "Contest-Times")"
		log "Reading [Contest-Times]:
		$TIMES"

		# For each start-time and end-time, check if we're in between.
		while read -r START END; do
			START_SECONDS=$(date --date="TZ=\"$TIMEZONE\" $START" +'%s')
			END_SECONDS=$(date --date="TZ=\"$TIMEZONE\" $END" +'%s')
			if [ "$CURRENT_TIME_SECONDS" -ge "$START_SECONDS" ] &&
				[ "$CURRENT_TIME_SECONDS" -lt "$END_SECONDS" ]; then
				NEW_MODE="contest"
				NEW_MODE_START_TIME_UTC=$(date --utc --iso-8601="seconds" --date="@$START_SECONDS")
				NEW_MODE_END_TIME_UTC=$(date --utc --iso-8601="seconds" --date="@$END_SECONDS")
			fi
			update_next_apply "$START"
			update_next_apply "$END"
		done < <(echo "$TIMES" | xargs -n 2)
	fi

	log "Selected mode to apply:
	NEW_MODE=$NEW_MODE
	NEW_MODE_START_TIME_UTC=$NEW_MODE_START_TIME_UTC
	NEW_MODE_END_TIME_UTC=$NEW_MODE_END_TIME_UTC"

	return 0 # success
}

schedule_next_mode_change() {
	local FORMATED_NEXT_TIME

	## Remove previous apply jobs
	for i in $(atq | cut -f 1); do
		atrm "$i"
	done

	### Schedule next apply job
	if [ "$EXECUTION_NEXT_SCHEDULED_APPLY_TIME" ]; then
		FORMATED_NEXT_TIME=$(date -d @"$EXECUTION_NEXT_SCHEDULED_APPLY_TIME" +"%Y%m%d%H%M.%S")
		log "Scheduling next apply job at $FORMATED_NEXT_TIME"
		echo "systemctl start happly.service" | at -t "$FORMATED_NEXT_TIME"
	fi
	return 0
}

set_timezone() {
	TIMEZONE="$(get_directives_var "Global" "TimeZone")"
	timedatectl set-timezone "$TIMEZONE"
	log "+Setting timezone to $TIMEZONE"
}

set_keyboards() {

	local LAYOUT XKBS
	AVAILABLE_KEYBOARD_LAYOUTS="$(get_directives_var "Global" "AvailableKeyboardLayouts")"
	KEYBOARDS=$(echo $AVAILABLE_KEYBOARD_LAYOUTS | sed 's/|/ /g')
	XKB=""

	for LAYOUT in $KEYBOARDS; do
		XKB+=" ('xkb', '$LAYOUT')"
	done

	XKBS="[$(echo $XKB | sed 's/) (/), (/g')]"
	su contestant -c "export DISPLAY=:0; gsettings set org.gnome.desktop.input-sources sources \"$XKBS\""

	log "+Setting available keyboards to -> $KEYBOARDS"
}

set_current_keyboard() {

	# If the mode is contest, let's stop updating this as it can modify the current
	# while the user is typing.
	if ! system_has_just_booted && [ "$NEW_MODE" = "contest" ]; then
		log "-Cannot modify default keyboard while in contest mode."
		return 0
	fi

	local LAYOUT
	AVAILABLE_KEYBOARD_LAYOUTS="$(get_directives_var "Global" "AvailableKeyboardLayouts")"
	DEFAULT_KEYBOARD_LAYOUT="$(get_directives_var "Global" "DefaultKeyboardLayout")"
	KEYBOARDS=$(echo $AVAILABLE_KEYBOARD_LAYOUTS | sed 's/|/ /g')
	IDX=0

	for LAYOUT in $KEYBOARDS; do
		if [ "$LAYOUT" = "$DEFAULT_KEYBOARD_LAYOUT" ]; then
			break
		fi
		let "IDX+=1"
	done

	su contestant -c "export DISPLAY=:0; gsettings set org.gnome.desktop.input-sources current $IDX"
	log "Setting current keyboard to -> $DEFAULT_KEYBOARD_LAYOUT"
}

set_network_filters() {

	log " Starting network filters"

	ALLOWED_WEBSITES="$(get_directives_var "$DIRECTIVES_SPECIFIC_CONFIG" "AllowedWebsites")"

	case $ALLOWED_WEBSITES in
	"all") firewall_accept_all ;;
	*) firewall_accept_filtered_web ;;
	esac

	return 0 # success
}

set_hmount_rules() {

	local MOUNT_POINTS MNT
	ALLOW_USB_STORAGE="$(get_directives_var "$DIRECTIVES_SPECIFIC_CONFIG" "AllowUsbStorage")"

	if [ "$ALLOW_USB_STORAGE" = "true" ]; then
		hos-usb --enable
	else
		## Change the rule
		hos-usb --disable

		## For each device mounted, kill all processes that are using the mount point, then umount
		TMP_SYSTEM_UUID="$(cmdline_value system.uuid)"
		TMP_EVENT_UUID="$(cmdline_value event.uuid)"
		TMP_CONTEST_UUID="$(cmdline_value contest.uuid)"
		REGEX="$(blkid | grep -v -E "$TMP_SYSTEM_UUID|$TMP_EVENT_UUID|$TMP_CONTEST_UUID" | cut -d: -f1 | tr '\n' '|')"
		MOUNT_POINTS="$(cat /proc/mounts | grep -E "${REGEX}popo" | grep -E '/dev/sd([a-z]|[a-z][a-z])' | awk '{ print $1 }')"
		for MNT in $MOUNT_POINTS; do
			#force_umount $MNT
			if fuser -k -m "$MNT" || true; then
				umount --lazy "$MNT"
				rm -rf "$MNT"
				sed "s%.*$MNT.*%%g" -i /etc/fstab
				systemctl disable "media-$(basename "$MNT").mount"
				rm -rf "/etc/systemd/system/media-$(basename "$MNT").mount"
			fi
		done
	fi

	return 0 # success
}

set_software() {

	AVAILABLE_SOFTWARE="$(get_directives_var "$DIRECTIVES_SPECIFIC_CONFIG" "AvailableSoftware")"
	SOFTWARE_LIST="$(echo "$AVAILABLE_SOFTWARE" | sed 's/|/ /g')"

	log " Activating software modules:"
	cp -f /etc/hmm/any /etc/hmm/current
	for SFW in $SOFTWARE_LIST; do
		sed "s:$SFW.*:$SFW\t\t\ttrue:g" -i /etc/hmm/current
		echo -e "\t\t$SFW" | tee -a /var/log/hsync.log
	done

	hmm -uf --block-update /etc/hmm/current | sed -r "s/\x1B\[(([0-9]{1,2})?(;)?([0-9]{1,2})?)?[m,K,H,f,J]//g" | tee -a /var/log/hsync.log

	## Special cases
	chown -R contestant:contestant /home/contestant/.config/JetBrains
	rm -f /home/contestant/.config/plank/dock1/launchers/{chromium,firefox}.dockitem
	if [ "$(echo $SOFTWARE_LIST | sed 's: :\n:g' | grep internet/chromium)" != "" ]; then
		echo -e "[PlankDockItemPreferences]\nLauncher=file:///usr/share/applications/chromium.desktop" >/home/contestant/.config/plank/dock1/launchers/chromium.dockitem
		chown contestant:contestant /home/contestant/.config/plank/dock1/launchers/chromium.dockitem
	elif [ "$(echo $SOFTWARE_LIST | sed 's: :\n:g' | grep internet/firefox)" != "" ]; then
		echo -e "[PlankDockItemPreferences]\nLauncher=file:///usr/share/applications/firefox.desktop" >/home/contestant/.config/plank/dock1/launchers/firefox.dockitem
		chown contestant:contestant /home/contestant/.config/plank/dock1/launchers/firefox.dockitem
	fi

	log_aufs_branches

	return 0 # success
}

# Set default bookmarks on web browsers.
# Currently, only Firefox and Chromium are supported.
set_bookmarks() {

	BOOKMARKS="$(get_directives_var "$DIRECTIVES_SPECIFIC_CONFIG" "Bookmarks")"
	log " Setting bookmarks"
	echo "${BOOKMARKS}" > /usr/share/current-bookmarks
}

set_wallpaper() {

	local NAME FILE
	WALLPAPER="$(get_directives_var "$DIRECTIVES_SPECIFIC_CONFIG" "Wallpaper")"

	if [ "$WALLPAPER" = "default" ]; then
		log " Setting default huronOS wallpaper"
		su contestant -c "export DISPLAY=:0; gsettings set org.gnome.desktop.background picture-uri file:///usr/share/backgrounds/huronos-background.png"
		return 0 # success
	fi

	log " Downloading wallpaper $WALLPAPER"
	NAME=$(basename "$WALLPAPER")
	FILE="/usr/share/backgrounds/custom-background-$$-$NAME"
	if wget --no-cache --tries=2 --timeout=10 "$WALLPAPER" -O "$FILE"; then
		log "+Setting new wallpaper"
		chmod 777 "$FILE"
		su contestant -c "export DISPLAY=:0; gsettings set org.gnome.desktop.background picture-uri file://$FILE"
		find /usr/share/backgrounds/ | grep custom-background | grep -v $$ | xargs -n 1 rm -f
		return 0 # success
	fi
	rm -f "$FILE"
	log "-Wallpaper cannot be downloaded. Wrong URL?, No internet?"

	# There's a chance that if persistence is set, and this is a restoration of a previous state
	# the background image stills available. Let's search for it.
	log " Attempting to restore previous background image"
	FILE="$(ls /usr/share/backgrounds/ | sed 's: :\n:g' | grep "$NAME" | head -n 1)"
	if [ "$FILE" != "" ]; then
		FILE="/usr/share/backgrounds/${FILE}"
		log "+Wallpaper found: $FILE, restoring wallpaper"
		chmod 777 $FILE
		su contestant -c "export DISPLAY=:0; gsettings set org.gnome.desktop.background picture-uri file://$FILE"
		find /usr/share/backgrounds/ | grep custom-background | grep -v "$FILE" | xargs -n 1 rm -f
		return 0 #success
	fi

	log "-Couldn't find any background to restore"
	return 1 # error
}
