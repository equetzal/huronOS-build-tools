#!/bin/bash

#	libhpersistence.sh (hsync.sh library)
#	This library contains functions to modify the AUFS union layers and set
#	them to the necesary arangement for the modality of huronOS and change
#	the persistence disk depending on the current modality.

#	Copyright (C) 2022, huronOS Project:
#		<http://huronos.org>
#
#	Licensed under the GNU GPL Version 2
#		<http://www.gnu.org/licenses/gpl-2.0.html>
#
#	Authors:
#		Enya Quetzalli <equetzal@huronos.org>
#		Abraham Omar   <aomm@huronos.org>


# This is the first execution of hsync, here we don't have a current state.
# It is 'none', so in this part we need to either set a previous persistent state
# or set 'always' mode if no other state is available.
start_persistence(){

	log " Starting a new persistent layer on AUFS."
	systemctl stop lightdm
	systemctl stop user@1000.service
	sleep 2

	case $STATE_MODE in
		# If there's no STATE_MODE, then there was no persistence set.
		# Let's clean the partition and start the always mode
		"none")
			log "-No previous state found, creating new persistence in always mode"
			start_always_mode || return 1 # error
			return 0 # sucess
			;;

		# If the state was always, then let's restore the files
		"always")
			log "+Previous state found, restoring persistence in always mode"
			restore_always_mode || return 1
			return 0 # sucess
			;;

		# If the state was event, then let's restore the files
		"event")
			log "+Previous state found, restoring persistence in event mode"
			restore_event_mode || return 1
			return 0 # sucess
			;;

		# If the state was contest, then let's restore the files
		"contest")
			log "+Previous state found, restoring persistence in contest mode"
			restore_contest_mode || return 1
			return 0 # sucess
			;;
	esac

	return 0
}

# This function is supposed to be called when there's a mode already set,
# so that this function only change the persistence between modes.
apply_persistence_mode(){

	if ! system_has_persistece_enabled; then
		STATE_IS_PERSISTENCE_ENABLED="false"
		log_aufs_branches
		return 0 #success
	fi

	if [ "$STATE_MODE" = "none" ]; then
		log "!Hey state was set to none, How is this possible?, Did the boot hsync failed?
		Starting a persistent mode for security!"
		start_persistence
	fi

	## Check if the current state is the same as the directives specified mode.
	if is_running_mode_same_as_new_mode; then
		log "+The following mode timeframes are considered to be the same:
		#1: $STATE_MODE
		    $STATE_MODE_START_TIME_UTC - $STATE_MODE_END_TIME_UTC
		#2: $NEW_MODE
		    $NEW_MODE_START_TIME_UTC - $NEW_MODE_END_TIME_UTC
		No modification will be done on persistence, preserving changes."
		log_aufs_branches
		return 0 # success.
	else
		log "+The following mode timeframes are considered to be the different:
		#1: $STATE_MODE
		    $STATE_MODE_START_TIME_UTC - $STATE_MODE_END_TIME_UTC
		#2: $NEW_MODE
		    $NEW_MODE_START_TIME_UTC - $NEW_MODE_END_TIME_UTC
		Modifications to persistence will be done."
	fi

	#set -x
	[ "$STATE_MODE" = "always" ]	&& [ "$NEW_MODE" = "event" ]	&& always_to_event
	[ "$STATE_MODE" = "always" ]	&& [ "$NEW_MODE" = "contest" ]	&& always_to_contest
	[ "$STATE_MODE" = "event" ]		&& [ "$NEW_MODE" = "always" ]	&& event_to_always
	[ "$STATE_MODE" = "event" ]		&& [ "$NEW_MODE" = "event" ]	&& event_to_event
	[ "$STATE_MODE" = "event" ]		&& [ "$NEW_MODE" = "contest" ]	&& event_to_contest
	[ "$STATE_MODE" = "contest" ]	&& [ "$NEW_MODE" = "always" ]	&& contest_to_always
	[ "$STATE_MODE" = "contest" ]	&& [ "$NEW_MODE" = "event" ]	&& contest_to_event
	[ "$STATE_MODE" = "contest" ]	&& [ "$NEW_MODE" = "contest" ]	&& contest_to_contest
	#set +x

	STATE_IS_PERSISTENCE_ENABLED="true"
	[ "$NEW_MODE" = "always" ] && STATE_PERSISTENCE_DISK="event"
	[ "$NEW_MODE" = "event" ] && STATE_PERSISTENCE_DISK="event"
	[ "$NEW_MODE" = "contest" ] && STATE_PERSISTENCE_DISK="contest"

	log_aufs_branches
	return 0
}

## Given a persistent branch currently part of the AUFS union
#  let it be free. That is, removing the branch from the union.
# $1 = Branch to free
free_branch(){
	local BRANCH PIDS PID
	BRANCH="$1"

	## First, let's quit all the modules as they may lock the persistent branch
	auls
	hmm -f --block-update "/etc/hmm/any"
	auls

	## Now, we will stop the user interface as budgie regulary keep cache files that locks the branch
	systemctl stop lightdm.service
	systemctl stop user@1000.service
	sleep 2

	## Let's try to remove the branch from AUFS
	mount -t aufs -o remount,del:"$BRANCH" aufs / 2>/dev/null
	[ $? -eq 0 ] && return 0
	auls

	## Ok, we cannot remove the AUFS branch, so, a non-graphical process is locking the branch
	# we will try killing all processes that are locking them. If huronOS is well configured,
	# any important process should be locking the branch
	for i in {1..50} ; do
		echo -n "Try #$i"
		sleep "$(echo 0.1*"$i" | bc)"
		PIDS="$(aubusy -v / "$BRANCH" | awk '{print $1}' | sort -u | tr '\n' ' ')"
		echo "pids=\"$PIDS\""
		for PID in $PIDS; do
			echo "Killing process with ID $PID aka. $(ps -p "$PID" -o command --no-headers | awk '{print $1}')"
			kill -9 "$PID" >/dev/null 2>/dev/null
		done
		## Let's retry to remove the branch
		mount -t aufs -o remount,del:"$BRANCH" aufs / 2>/dev/null
		[ $? -eq 0 ] && echo && return 0 # We are free!!
	done
	echo
	log " Couldn't remove $BRANCH from AUFS / filesystem"

	## We couldn't change mode. TODO: Find the right decistion of what to do on here
	# in the meanwhile, we can disable our service, restart the UI and exit with error.
	systemctl mask hsync.timer
	systemctl mask hsync.service
	systemctl mask happly.service
	systemctl start lightdm.service

	su contestant -c '(\
		export DISPLAY=:0; \
		sleep 5s; \
		zenity \
		--error \
		--title="huronOS fatal error."\
		--text="
<b>If you are a contestant, contact a staff member for help.</b>
huronOS is not able to change its modality behaviour due to a conflicting process locking the current persistent branch (persistent user data) on AUFS.
The sync manager could not found the process that its locking the system, so it cannot continue and finding the pid manually will be complicated.
Please reboot the system in order to unlock AUFS.
If this is happening during a contest <b> please, for precaution make sure to save the persistent data before starting the contest system again.</b>

To save the user data, with a root terminal please run:
<span foreground=\"#aaa\" background=\"#444\">
<tt>hos-usb --enable</tt>
</span>
This will allow USB connections. Then, backup the user data, finally reboot."\
		--width=500 \
		>/dev/null 2>/dev/null\
	) &'
	exit 3
	## TODO: Use reboot as alternative method if the the AUFS branch cannot be removed.

}

## Branch is unified into AUFS and then realeased for user to use.
# $1 = Branch to release
release_branch(){
	local BRANCH
	BRANCH="$1"

	mount -t aufs -o remount,prepend:"$BRANCH" aufs /
	su contestant -c '(xdg-user-dirs-update --force)'
	systemctl start lightdm
	sleep 2
}

## Cleans the given partition of ANY file, then creates the base dirs that will redirect
# the AUFS tdp create policy to save changes on usrchanges instead of syschanges
# $1 = Mount point to clean, should be writtable
prepare_perch(){
	local DIR
	DIR="$1"

	## Clean directory
	chattr -R -i "$DIR/"
	chown -R root:root "$DIR/"
	rm -rf "${DIR:?}"/* 2>/dev/null || true
	rm -rf "${DIR:?}"/.* 2>/dev/null || true

	## By doing this, all the files created under this directories will be saved on usrchanges/
	# Also, because all the modules/ are mounted between syschanges/ on the low, and usrchanges/ on the top
	# the files modified or edited by the software modules will be copied up to the bottom-up writtable branch
	# of where the file was located, so, only usrchages/ is rw. Then software preferences should be sorted here.
	mkdir -p "$DIR"/home/contestant/{Desktop,Documents,Downloads,Music,Pictures,Public,Templates,Videos,.config,.local}
	chown -R contestant:contestant "$DIR"/home/contestant
	mkdir -p "$DIR"/usr/share/backgrounds/
}

## Saves the changes of a partition on the selected directory with the date and hour stamp
# $1 = partition mount point
# $2 = destiny directory to save
# $3 = preffix of directory where changes will be saved
save_changes(){
	local ORIGIN DESTINY PREFFIX DIR
	ORIGIN="$1"
	DESTINY="$2"
	PREFFIX="$3"
	DIR="$DESTINY/$PREFFIX-$(date '+%Y-%m-%d_%H.%M')"

	mkdir -p "$DIR"
	cp -rf --verbose "$ORIGIN"/* "$DIR"/
	chown contestant:contestant "$DIR"
}

start_always_mode(){
	# Let's deactivate all modules to prevent syschanges/ to stay at a higher index layer
	# than any module. That would cause that modularized-software changes to be saved
	# on the syschanges/ instead of the usrchanges/
	hmm -f --block-update /etc/hmm/any

	## Bind the mount to the usrchanges as an intermediate layer.
	mount --bind "$EVENT_MNT" "$USRCHANGES"

	## Clean the disk, create base directory tree to allow AUFS copyup policy
	prepare_perch "$USRCHANGES"

	# At this moment, usrchanges/ branch is not used by anyone so we should be able to
	# prepend it without needing to restart any graphical service.
	mount -t aufs -o remount,prepend:"$USRCHANGES" aufs /

	## Let's notify the state that we're setting
	STATE_MODE="always"
	STATE_MODE_START_TIME_UTC=""
	STATE_MODE_END_TIME_UTC=""
	STATE_IS_PERSISTENCE_ENABLED="true"
	STATE_PERSISTENCE_DISK="event"

	log_aufs_branches
	systemctl start lightdm
	sleep 2

	return 0
}

restore_always_mode(){

	# Silently deactivate all modules to prevent syschanges/ to stay at a higher index layer
	# than any module. That would cause that modularized-software changes to be saved
	# on the syschanges/ instead of the usrchanges/
	hmm -f --block-update /etc/hmm/any

	## Bind the mount to the usrchanges as an intermediate layer.
	mount --bind "$EVENT_MNT" "$USRCHANGES"

	# At this moment, usrchanges/ branch is not used by anyone so we should be able to
	# prepend it without needing to restart any graphical service.
	mount -t aufs -o remount,prepend:"$USRCHANGES" aufs /

	## Let's notify the state that we're setting
	STATE_MODE="always"
	STATE_IS_PERSISTENCE_ENABLED="true"
	STATE_PERSISTENCE_DISK="event"

	log_aufs_branches
	#su contestant -c '(xdg-user-dirs-update --force)'
	systemctl start lightdm
	sleep 2

	return 0
}

restore_event_mode(){

	# Silently deactivate all modules to prevent syschanges/ to stay at a higher index layer
	# than any module. That would cause that modularized-software changes to be saved
	# on the syschanges/ instead of the usrchanges/
	hmm -f --block-update /etc/hmm/any

	## Bind the mount to the usrchanges as an intermediate layer.
	mount --bind "$EVENT_MNT" "$USRCHANGES"

	# At this moment, usrchanges/ branch is not used by anyone so we should be able to
	# prepend it without needing to restart any graphical service.
	mount -t aufs -o remount,prepend:"$USRCHANGES" aufs /

	## Let's notify the state that we're setting
	STATE_MODE="event"
	STATE_IS_PERSISTENCE_ENABLED="true"
	STATE_PERSISTENCE_DISK="event"

	log_aufs_branches
	#su contestant -c '(xdg-user-dirs-update --force)'
	systemctl start lightdm
	sleep 2

	return 0
}

restore_contest_mode(){

	# Silently deactivate all modules to prevent syschanges/ to stay at a higher index layer
	# than any module. That would cause that modularized-software changes to be saved
	# on the syschanges/ instead of the usrchanges/
	hmm -f --block-update "/etc/hmm/any"

	## Bind the mount to the usrchanges as an intermediate layer.
	mount --bind "$CONTEST_MNT" "$USRCHANGES"

	# At this moment, usrchanges/ branch is not used by anyone so we should be able to
	# prepend it without needing to restart any graphical service.
	mount -t aufs -o remount,prepend:"$USRCHANGES" aufs /

	## Let's notify the state that we're setting
	STATE_MODE="contest"
	STATE_IS_PERSISTENCE_ENABLED="true"
	STATE_PERSISTENCE_DISK="contest"

	log_aufs_branches
	#su contestant -c '(xdg-user-dirs-update --force)'
	systemctl start lightdm
	sleep 2

	return 0
}

always_to_event(){
	free_branch "$USRCHANGES"
	prepare_perch "$USRCHANGES"
	release_branch "$USRCHANGES"
	return 0
}

always_to_contest(){
	free_branch "$USRCHANGES"
	umount "$USRCHANGES"
	prepare_perch "$CONTEST_MNT"
	mount --bind "$CONTEST_MNT" "$USRCHANGES"
	release_branch "$USRCHANGES"
	return 0
}

event_to_always(){
	free_branch "$USRCHANGES"
	prepare_perch "$USRCHANGES"
	release_branch "$USRCHANGES"
	return 0
}

event_to_event(){
	free_branch "$USRCHANGES"
	prepare_perch "$USRCHANGES"
	release_branch "$USRCHANGES"
	return 0
}

event_to_contest(){
	free_branch "$USRCHANGES"
	umount "$USRCHANGES"
	prepare_perch "$CONTEST_MNT"
	mount --bind "$CONTEST_MNT" "$USRCHANGES"
	release_branch "$USRCHANGES"
	return 0
}

contest_to_always(){
	free_branch "$USRCHANGES"
	umount "$USRCHANGES"
	prepare_perch "$EVENT_MNT"
	save_changes "$CONTEST_MNT" "$EVENT_MNT/home/contestant" "contest"
	prepare_perch "$CONTEST_MNT"
	mount --bind "$EVENT_MNT" "$USRCHANGES"
	release_branch "$USRCHANGES"
	return 0
}

contest_to_event(){
	free_branch "$USRCHANGES"
	umount "$USRCHANGES"
	save_changes "$CONTEST_MNT" "$EVENT_MNT/home/contestant" "contest"
	prepare_perch "$CONTEST_MNT"
	mount --bind "$EVENT_MNT" "$USRCHANGES"
	release_branch "$USRCHANGES"
	return 0
}

contest_to_contest(){
	free_branch "$USRCHANGES"
	save_changes "$CONTEST_MNT" "$EVENT_MNT/home/contestant" "contest"
	prepare_perch "$USRCHANGES"
	release_branch "$USRCHANGES"
	return 0
}

