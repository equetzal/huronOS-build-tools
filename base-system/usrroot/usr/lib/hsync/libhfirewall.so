#!/bin/bash

#	libhfirewall.sh (hsync.sh library)
#	This library contains functions to configure iptables firewall
#	according to the exeptions specified on the directives.
#
#	Copyright (C) 2022, huronOS Project:
#		<http://huronos.org>
#
#	Licensed under the GNU GPL Version 2
#		<http://www.gnu.org/licenses/gpl-2.0.html>
#
#	Authors:
#		Enya Quetzalli <equetzal@huronos.org>
#		Abraham Omar   <aomm@huronos.org>

enable_network_interfaces(){
	declare INTERFACES="$(ip -o -br link | awk '{print $1}' | tr '\n' ' ')"

	rfkill unblock all
	for INTERF in $INTERFACES; do
		ip link set $INTERF up
	done

	return 0 # success
}

get_ip_from_url(){
	## Default IP is empty (if the URL is not an IP and the domain cannot resolve to an IP, the IP is empty)
	local IP=""
	local URL=$1
  	# Define the regular expression to match a domain or an IP
  	local URL_REGEX="^(https?:\/\/)?([^\/:]+)(:[0-9]+)?\/?.*$"
	# Test if the URL matches the regular expression
	if [[ $URL =~ $URL_REGEX ]]; then
		# If it does, extract the domain & subdomains (if it has) from the second group
		local DOMAIN=${BASH_REMATCH[2]}
	fi

	# Define the regular expression for an IP address
	local IP_REGEX="^([0-9]{1,3}\.){3}[0-9]{1,3}$"

	# Test if the string matches the regular expression
	if [[ $DOMAIN =~ $IP_REGEX ]]; then
		# If is a match, we got the IP
		IP=$DOMAIN
	else
		# If there's no match, query the DNS server for the IP address
		# If the dig command succeeds (i.e., returns an exit status of 0), the IP address
		# is stored in the $IP variable.
		if ! IP="$(dig +time=3 +tries=1 +short "$DOMAIN" A)"; then
			## Set empty IP
			IP=""
		fi
	fi

	# Output the IP address or domain name
	echo "$IP"
}


firewall_accept_all(){

	enable_network_interfaces

	## Set all policies to ACCEPT
	iptables -P INPUT ACCEPT
	iptables -P OUTPUT ACCEPT
	iptables -P FORWARD ACCEPT

	## Clean rules
	iptables -F INPUT
	iptables -F OUTPUT
	iptables -F FORWARD

	## Clean chains
	iptables -X
	iptables -Z

	log "Setting firewall rules to:
	$(iptables --list)"

	return 0
}

firewall_filter_ipv4(){

	## Get all the IP addresses to ALLOW web traffic
	declare DIRECTIVES_FILE_IP="$(get_ip_from_url "$DIRECTIVES_FILE_URL")"
	declare DIRECTIVES_SERVER_IP="$(grep DIRECTIVES_SERVER_IP "$CURRENT_SYNC_SERVER_CONFIG_FILE" | cut -d= -f2)"
	declare WALLPAPER_DOMAIN="$(get_directives_var "$DIRECTIVES_SPECIFIC_CONFIG" "Wallpaper")"
	declare WALLPAPER_IP="$(get_ip_from_url "$WALLPAPER_DOMAIN")"
	declare ALLOWED_WEBSITES="$(get_directives_var "$DIRECTIVES_SPECIFIC_CONFIG" "AllowedWebsites" | sed 's/|/ /g')"
	declare ALLOW_IPS=""

	ALLOW_IPS+=" $DIRECTIVES_FILE_IP"
	ALLOW_IPS+=" $DIRECTIVES_SERVER_IP"
	ALLOW_IPS+=" $WALLPAPER_IP"

	if [ "$ALLOWED_WEBSITES" != "any" ];then
		for WEBSITE_URL in $ALLOWED_WEBSITES; do
			IP="$(get_ip_from_url "$WEBSITE_URL")"
			ALLOW_IPS+=" $IP"
		done
	fi

	# Delete repeated ips
	ALLOW_IPS="$(echo -n "$ALLOW_IPS" | sed 's: :\n:g' | sort -u | sed 's:\n: :g')"

	# Set policy to deny all input
	# We don't need to take care of the output, what we want is user not to receive data.
	iptables -P INPUT DROP
	iptables -P OUTPUT ACCEPT
	iptables -P FORWARD ACCEPT

	## Clean rules
	iptables -F INPUT
	iptables -F OUTPUT
	iptables -F FORWARD

	## Clean chains
	iptables -X
	iptables -Z

	## Allow ALL loopback
	iptables -A INPUT -i lo -j ACCEPT

	## Allow ICMP
	iptables -A INPUT -p icmp -j ACCEPT

	## Allow DHCP
	iptables -A INPUT -p udp --sport 67 --dport 68 -m state --state RELATED,ESTABLISHED -j ACCEPT

	## Allow DNS
	iptables -A INPUT -p udp --sport 53 -j ACCEPT
	iptables -A INPUT -p tcp --sport 53 -j ACCEPT

	## Allow NTP time sync
	iptables -A INPUT -p udp --sport 123 -m state --state NEW,RELATED,ESTABLISHED -j ACCEPT

	## Allow Crow Translate to use googleapis, this does allow access to search engine or web proxy via google
	iptables -A INPUT -p tcp -m multiport --sport 443 -s translate.googleapis.com -m state --state ESTABLISHED,RELATED -j ACCEPT

	## Allow resolved ips on the directives file
	for IP in $ALLOW_IPS; do
		## Start ip filtering
		iptables -A INPUT -p tcp -m multiport --sport 80,443,8080 -s $IP -m state --state ESTABLISHED,RELATED -j ACCEPT
	done

	return 0
}

firewall_filter_ipv6(){
	#TODO: Implement
	return 0
}

firewall_accept_filtered_web(){

	enable_network_interfaces
	firewall_filter_ipv4
	firewall_filter_ipv6

	log "Setting firewall rules to:
	$(iptables-legacy --list)"

	return 0
}
