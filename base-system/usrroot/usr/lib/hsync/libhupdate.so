#!/bin/bash

#	libhupdate.sh (hsync.sh library)
#	This library contains functions to download the directives file
#	from the huronOS directives server, and then compare it's values
#	with the current directives file, then decide if the directives
#	needs to be applied based on the current time, the directives and
#	changes on it.
#
#	Copyright (C) 2022, huronOS Project:
#		<http://huronos.org>
#
#	Licensed under the GNU GPL Version 2
#		<http://www.gnu.org/licenses/gpl-2.0.html>
#
#	Authors:
#		Enya Quetzalli <equetzal@huronos.org>
#		Abraham Omar   <aomm@huronos.org>

## Try the download of the directives file, and if succeed it validates the syntax of the file.
try_directives_download() {

	## Get the directives file URL
	DIRECTIVES_FILE_URL="$(grep DIRECTIVES_FILE_URL "$CURRENT_SYNC_SERVER_CONFIG_FILE" | cut -d= -f2)"
	DIRECTIVES_TEMP_FILE="/tmp/directives-$$.hdf"

	if ! wget --no-cache --tries=2 --timeout=10 -O $DIRECTIVES_TEMP_FILE $DIRECTIVES_FILE_URL; then
		log "-Directives file cannot be downloaded"
		return 1 # error
	fi
	log "+Directives file $DIRECTIVES_TEMP_FILE, successfuly downloaded"
	log " Downloaded directives file contents:\n$(cat $DIRECTIVES_TEMP_FILE)\n"

	# Ok, so we have a new directives file, we must have to check it follows the syntaxis
	# or the directives comparison between old and new directives file will crash.
	# If directives files does not follow the syntax, let's just drop the file.
	## Check if directives file follows the syntaxis

	#log " Syntax revision over $DIRECTIVES_TEMP_FILE"
	#if ! timeout 2 /usr/lib/hsync/hsync.validator $DIRECTIVES_TEMP_FILE >> /var/log/hsync.log; then
	# 	log "-Directives file $DIRECTIVES_TEMP_FILE have an invalid syntaxis. Droping file."
	# 	rm -f $DIRECTIVES_TEMP_FILE
	# 	return 1 # error
	#fi

	log "+Directives file $DIRECTIVES_TEMP_FILE have a valid syntaxis."
	return 0 #success
}

## Compare the same variable over two different configuration files
# $1 = variable name
# $2 = configuration A
# $3 = configuration B
is_var_equal() {
	if [ "$(echo "$2" | grep "$1" | cut -d= -f2)" = "$(echo "$3" | grep "$1" | cut -d= -f2)" ]; then
		return 0 # true, equal
	fi
	return 1 # false, not-equal
}

## Returns true if some variable on the global config is different between files
have_global_config_changed() {

	## It's supposed that at this point, $DIRECTIVES_TEMP_FILE should exist, but no the directives file
	if [ ! -f $DIRECTIVES_FILE ]; then
		log "-No $DIRECTIVES_FILE found, Assuming Global directives have changed."
		return 0 # true, changed
	fi

	local CURRENT_DIRECTIVES NEW_DIRECTIVES
	CURRENT_DIRECTIVES="$(cat $DIRECTIVES_FILE | sed -nE "/^\[Global\]$/{:l n;/^(\[.*\])?$/q;p;bl}")"
	NEW_DIRECTIVES="$(cat $DIRECTIVES_TEMP_FILE | sed -nE "/^\[Global\]$/{:l n;/^(\[.*\])?$/q;p;bl}")"

	is_var_equal "TimeZone" "$CURRENT_DIRECTIVES" "$NEW_DIRECTIVES" || return 0                 # true, have-changed
	is_var_equal "ConfigExpirationTime" "$CURRENT_DIRECTIVES" "$NEW_DIRECTIVES" || return 0     # true, have-changed
	is_var_equal "AvailableKeyboardLayouts" "$CURRENT_DIRECTIVES" "$NEW_DIRECTIVES" || return 0 # true, have-changed
	is_var_equal "DefaultKeyboardLayout" "$CURRENT_DIRECTIVES" "$NEW_DIRECTIVES" || return 0    # true, have-changed
	is_var_equal "EventConfig" "$CURRENT_DIRECTIVES" "$NEW_DIRECTIVES" || return 0              # true, have-changed
	is_var_equal "ContestConfig" "$CURRENT_DIRECTIVES" "$NEW_DIRECTIVES" || return 0            # true, have-changed

	return 1 # false, have-not-changed
}

## Returns true if some variable on the specific config is different between files
# $1 = specific config name
have_specific_config_changed() {

	## It's supposed that at this point, $DIRECTIVES_TEMP_FILE should exist, but no the directives file
	if [ ! -f $DIRECTIVES_FILE ]; then
		log "-No $DIRECTIVES_FILE found, Assuming $1 directives have changed."
		return 0 # true, changed
	fi

	local SECTION CURRENT_DIRECTIVES NEW_DIRECTIVES
	SECTION="$1"
	CURRENT_DIRECTIVES="$(cat $DIRECTIVES_FILE | sed -nE "/^\[$SECTION\]$/{:l n;/^(\[.*\])?$/q;p;bl}")"
	NEW_DIRECTIVES="$(cat $DIRECTIVES_TEMP_FILE | sed -nE "/^\[$SECTION\]$/{:l n;/^(\[.*\])?$/q;p;bl}")"

	is_var_equal "Wallpaper" "$CURRENT_DIRECTIVES" "$NEW_DIRECTIVES" || return 0         # true, have-changed
	is_var_equal "AllowUsbStorage" "$CURRENT_DIRECTIVES" "$NEW_DIRECTIVES" || return 0   # true, have-changed
	is_var_equal "AllowedWebsites" "$CURRENT_DIRECTIVES" "$NEW_DIRECTIVES" || return 0   # true, have-changed
	is_var_equal "Bookmarks" "$CURRENT_DIRECTIVES" "$NEW_DIRECTIVES" || return 0         # true, have-changed
	is_var_equal "AvailableSoftware" "$CURRENT_DIRECTIVES" "$NEW_DIRECTIVES" || return 0 # true, have-changed

	return 1 # false, have-not-changed
}

## Returns true if any character on the event times have changed
# $1 = specific config name
have_specific_times_changed() {

	## It's supposed that at this point, $DIRECTIVES_TEMP_FILE should exist, but no the directives file
	if [ ! -f $DIRECTIVES_FILE ]; then
		log "-No $DIRECTIVES_FILE found, Assuming $1 directives have changed."
		return 0 # true, changed
	fi

	local SECTION CURRENT_DIRECTIVES NEW_DIRECTIVES
	SECTION="$1"
	CURRENT_DIRECTIVES="$(cat $DIRECTIVES_FILE | sed -nE "/^\[$SECTION\]$/{:l n;/^(\[.*\])?$/q;p;bl}")"
	NEW_DIRECTIVES="$(cat $DIRECTIVES_TEMP_FILE | sed -nE "/^\[$SECTION\]$/{:l n;/^(\[.*\])?$/q;p;bl}")"

	if [ "$CURRENT_DIRECTIVES" = "$NEW_DIRECTIVES" ]; then
		return 1 # false, have-not-changed
	fi
	return 0 # true, have-changed
}

bool_to_string() {
	if [ $1 -eq 0 ]; then
		echo "true"
	else
		echo "false"
	fi
}

have_directives_changed() {
	have_global_config_changed
	DIRECTIVES_GLOBAL_CONFIG_HAVE_CHANGED=$?
	have_specific_config_changed "Always"
	DIRECTIVES_ALWAYS_CONFIG_HAVE_CHANGED=$?
	have_specific_config_changed "Event"
	DIRECTIVES_EVENT_CONFIG_HAVE_CHANGED=$?
	have_specific_config_changed "Contest"
	DIRECTIVES_CONTEST_CONFIG_HAVE_CHANGED=$?
	have_specific_times_changed "Event-Times"
	DIRECTIVES_EVENT_TIMES_HAVE_CHANGED=$?
	have_specific_times_changed "Contest-Times"
	DIRECTIVES_CONTEST_TIMES_HAVE_CHANGED=$?

	DIRECTIVES_HAVE_CHANGED=1 # false, not-changed
	if [ $DIRECTIVES_GLOBAL_CONFIG_HAVE_CHANGED -eq 0 ]; then DIRECTIVES_HAVE_CHANGED=0; fi
	if [ $DIRECTIVES_ALWAYS_CONFIG_HAVE_CHANGED -eq 0 ]; then DIRECTIVES_HAVE_CHANGED=0; fi
	if [ $DIRECTIVES_EVENT_CONFIG_HAVE_CHANGED -eq 0 ]; then DIRECTIVES_HAVE_CHANGED=0; fi
	if [ $DIRECTIVES_CONTEST_CONFIG_HAVE_CHANGED -eq 0 ]; then DIRECTIVES_HAVE_CHANGED=0; fi
	if [ $DIRECTIVES_EVENT_TIMES_HAVE_CHANGED -eq 0 ]; then DIRECTIVES_HAVE_CHANGED=0; fi
	if [ $DIRECTIVES_CONTEST_TIMES_HAVE_CHANGED -eq 0 ]; then DIRECTIVES_HAVE_CHANGED=0; fi

	log " Comparing new directives file, result:
	DIRECTIVES_HAVE_CHANGED=$(bool_to_string $DIRECTIVES_HAVE_CHANGED)
	DIRECTIVES_GLOBAL_CONFIG_HAVE_CHANGED=$(bool_to_string $DIRECTIVES_GLOBAL_CONFIG_HAVE_CHANGED)
	DIRECTIVES_ALWAYS_CONFIG_HAVE_CHANGED=$(bool_to_string $DIRECTIVES_ALWAYS_CONFIG_HAVE_CHANGED)
	DIRECTIVES_EVENT_CONFIG_HAVE_CHANGED=$(bool_to_string $DIRECTIVES_EVENT_CONFIG_HAVE_CHANGED)
	DIRECTIVES_CONTEST_CONFIG_HAVE_CHANGED=$(bool_to_string $DIRECTIVES_CONTEST_CONFIG_HAVE_CHANGED)
	DIRECTIVES_EVENT_TIMES_HAVE_CHANGED=$(bool_to_string $DIRECTIVES_EVENT_TIMES_HAVE_CHANGED)
	DIRECTIVES_CONTEST_TIMES_HAVE_CHANGED=$(bool_to_string $DIRECTIVES_CONTEST_TIMES_HAVE_CHANGED)"

	if [ $DIRECTIVES_HAVE_CHANGED -eq 0 ]; then
		log "+Directives file have changed"
		return 0 # true, have changed
	fi
	log "-Directives file have not changed, removing $DIRECTIVES_TEMP_FILE"
	rm -f $DIRECTIVES_TEMP_FILE
	return 1 # false, have not changed
}

## Return true if the directives are expired
# $1 = Directives file to test
directives_already_expired() {

	## In case the directives file does not exist, let's consider it expired
	if [ ! -f $1 ]; then
		log "-No $1 found, considering expired file."
		return 0 # true, have-expired
	fi

	## Check if the directives file was set to expire.
	local NEW_DIRECTIVES_EXPIRATION_TIME NEW_DIRECTIVES_TIMEZONE
	NEW_DIRECTIVES_EXPIRATION_TIME="$(cat $1 | grep ConfigExpirationTime | cut -d= -f2)"
	NEW_DIRECTIVES_TIMEZONE="$(cat $1 | grep TimeZone | cut -d= -f2)"

	## Oh, no expiration date. Then let's always return false as it has not expired :)
	if [ "$NEW_DIRECTIVES_EXPIRATION_TIME" = "never" ]; then
		return 1 # false, not-expired
	fi

	# Ok, so if the clock is sync with ntp server, we now this is accurate.
	# BUT, if the clock is not sync, then the hardware clock is the relevant, but it can be wrong :/
	# MORE if the installed OS has set the clock to take TZ as time instead of UTC.
	# TODO: Do something if the clock is not in sync, for now let's asume HW clock is OK.
	if [ "$(date -u +'%s')" -ge "$(date --date="TZ=\"$NEW_DIRECTIVES_TIMEZONE\" $NEW_DIRECTIVES_EXPIRATION_TIME" +'%s')" ]; then
		return 0 # true, have-expired
	fi

	update_next_apply $NEW_DIRECTIVES_EXPIRATION_TIME
	return 1 # false, not-expired
}

update_directives() {
	if directives_already_expired "$DIRECTIVES_TEMP_FILE"; then
		log "-The new directives file is already expired"
		rm -f $DIRECTIVES_TEMP_FILE
		return 1 # false, cannot update directives
	fi

	log "+Writting new directives file on $DIRECTIVES_FILE"
	mv $DIRECTIVES_TEMP_FILE $DIRECTIVES_FILE
	chmod 640 $DIRECTIVES_FILE
	return $?
}
