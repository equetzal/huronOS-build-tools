var search_data = {"index":{"searchIndex":["exceptionformatrix","errdimensionmismatch","errnotregular","erroperationnotdefined","erroperationnotimplemented","matrix","eigenvaluedecomposition","lupdecomposition","vector","zerovectorerror","*()","*()","**()","+()","+()","+@()","+@()","-()","-()","-@()","-@()","/()","/()","==()","==()","i()","[]()","[]()","[]()","[]()","[]=()","[]=()","abs()","adjugate()","angle_with()","antisymmetric?()","basis()","build()","coerce()","coerce()","cofactor()","cofactor_expansion()","collect()","collect()","collect!()","collect!()","collect2()","column()","column_vector()","column_vectors()","columns()","combine()","combine()","component()","component()","conj()","conjugate()","covector()","cross()","cross_product()","d()","det()","det()","det_e()","determinant()","determinant()","determinant_e()","diagonal()","diagonal?()","dot()","each()","each()","each2()","each_with_index()","eigen()","eigensystem()","eigenvalue_matrix()","eigenvalues()","eigenvector_matrix()","eigenvector_matrix_inv()","eigenvectors()","element()","element()","elements()","elements_to_f()","elements_to_f()","elements_to_i()","elements_to_i()","elements_to_r()","elements_to_r()","empty()","empty?()","entrywise_product()","eql?()","eql?()","find_index()","first_minor()","freeze()","freeze()","hadamard_product()","hash()","hash()","hermitian?()","hstack()","hstack()","identity()","imag()","imaginary()","independent?()","independent?()","index()","inner_product()","inspect()","inspect()","inv()","inverse()","l()","laplace_expansion()","lower_triangular?()","lup()","lup_decomposition()","magnitude()","map()","map()","map!()","map!()","map2()","minor()","new()","new()","new()","new()","new()","new()","new()","new()","norm()","normal?()","normalize()","orthogonal?()","p()","permutation?()","r()","rank()","rank_e()","real()","real?()","rect()","rectangular()","regular?()","round()","round()","row()","row_count()","row_size()","row_vector()","row_vectors()","rows()","scalar()","singular?()","singular?()","size()","skew_symmetric?()","solve()","square?()","symmetric?()","t()","to_a()","to_a()","to_a()","to_a()","to_ary()","to_ary()","to_matrix()","to_matrix()","to_s()","to_s()","tr()","trace()","transpose()","u()","unit()","unitary?()","upper_triangular?()","v()","v_inv()","vstack()","vstack()","zero()","zero()","zero?()","zero?()"],"longSearchIndex":["exceptionformatrix","exceptionformatrix::errdimensionmismatch","exceptionformatrix::errnotregular","exceptionformatrix::erroperationnotdefined","exceptionformatrix::erroperationnotimplemented","matrix","matrix::eigenvaluedecomposition","matrix::lupdecomposition","vector","vector::zerovectorerror","matrix#*()","vector#*()","matrix#**()","matrix#+()","vector#+()","matrix#+@()","vector#+@()","matrix#-()","vector#-()","matrix#-@()","vector#-@()","matrix#/()","vector#/()","matrix#==()","vector#==()","matrix::i()","matrix::[]()","matrix#[]()","vector::[]()","vector#[]()","matrix#[]=()","vector#[]=()","matrix#abs()","matrix#adjugate()","vector#angle_with()","matrix#antisymmetric?()","vector::basis()","matrix::build()","matrix#coerce()","vector#coerce()","matrix#cofactor()","matrix#cofactor_expansion()","matrix#collect()","vector#collect()","matrix#collect!()","vector#collect!()","vector#collect2()","matrix#column()","matrix::column_vector()","matrix#column_vectors()","matrix::columns()","matrix::combine()","matrix#combine()","matrix#component()","vector#component()","matrix#conj()","matrix#conjugate()","vector#covector()","vector#cross()","vector#cross_product()","matrix::eigenvaluedecomposition#d()","matrix#det()","matrix::lupdecomposition#det()","matrix#det_e()","matrix#determinant()","matrix::lupdecomposition#determinant()","matrix#determinant_e()","matrix::diagonal()","matrix#diagonal?()","vector#dot()","matrix#each()","vector#each()","vector#each2()","matrix#each_with_index()","matrix#eigen()","matrix#eigensystem()","matrix::eigenvaluedecomposition#eigenvalue_matrix()","matrix::eigenvaluedecomposition#eigenvalues()","matrix::eigenvaluedecomposition#eigenvector_matrix()","matrix::eigenvaluedecomposition#eigenvector_matrix_inv()","matrix::eigenvaluedecomposition#eigenvectors()","matrix#element()","vector#element()","vector::elements()","matrix#elements_to_f()","vector#elements_to_f()","matrix#elements_to_i()","vector#elements_to_i()","matrix#elements_to_r()","vector#elements_to_r()","matrix::empty()","matrix#empty?()","matrix#entrywise_product()","matrix#eql?()","vector#eql?()","matrix#find_index()","matrix#first_minor()","matrix#freeze()","vector#freeze()","matrix#hadamard_product()","matrix#hash()","vector#hash()","matrix#hermitian?()","matrix::hstack()","matrix#hstack()","matrix::identity()","matrix#imag()","matrix#imaginary()","vector::independent?()","vector#independent?()","matrix#index()","vector#inner_product()","matrix#inspect()","vector#inspect()","matrix#inv()","matrix#inverse()","matrix::lupdecomposition#l()","matrix#laplace_expansion()","matrix#lower_triangular?()","matrix#lup()","matrix#lup_decomposition()","vector#magnitude()","matrix#map()","vector#map()","matrix#map!()","vector#map!()","vector#map2()","matrix#minor()","exceptionformatrix::errdimensionmismatch::new()","exceptionformatrix::errnotregular::new()","exceptionformatrix::erroperationnotdefined::new()","exceptionformatrix::erroperationnotimplemented::new()","matrix::new()","matrix::eigenvaluedecomposition::new()","matrix::lupdecomposition::new()","vector::new()","vector#norm()","matrix#normal?()","vector#normalize()","matrix#orthogonal?()","matrix::lupdecomposition#p()","matrix#permutation?()","vector#r()","matrix#rank()","matrix#rank_e()","matrix#real()","matrix#real?()","matrix#rect()","matrix#rectangular()","matrix#regular?()","matrix#round()","vector#round()","matrix#row()","matrix#row_count()","matrix#row_size()","matrix::row_vector()","matrix#row_vectors()","matrix::rows()","matrix::scalar()","matrix#singular?()","matrix::lupdecomposition#singular?()","vector#size()","matrix#skew_symmetric?()","matrix::lupdecomposition#solve()","matrix#square?()","matrix#symmetric?()","matrix#t()","matrix#to_a()","matrix::eigenvaluedecomposition#to_a()","matrix::lupdecomposition#to_a()","vector#to_a()","matrix::eigenvaluedecomposition#to_ary()","matrix::lupdecomposition#to_ary()","matrix#to_matrix()","vector#to_matrix()","matrix#to_s()","vector#to_s()","matrix#tr()","matrix#trace()","matrix#transpose()","matrix::lupdecomposition#u()","matrix::unit()","matrix#unitary?()","matrix#upper_triangular?()","matrix::eigenvaluedecomposition#v()","matrix::eigenvaluedecomposition#v_inv()","matrix::vstack()","matrix#vstack()","matrix::zero()","vector::zero()","matrix#zero?()","vector#zero?()"],"info":[["ExceptionForMatrix","","ExceptionForMatrix.html","",""],["ExceptionForMatrix::ErrDimensionMismatch","","ExceptionForMatrix/ErrDimensionMismatch.html","",""],["ExceptionForMatrix::ErrNotRegular","","ExceptionForMatrix/ErrNotRegular.html","",""],["ExceptionForMatrix::ErrOperationNotDefined","","ExceptionForMatrix/ErrOperationNotDefined.html","",""],["ExceptionForMatrix::ErrOperationNotImplemented","","ExceptionForMatrix/ErrOperationNotImplemented.html","",""],["Matrix","","Matrix.html","","<p>The <code>Matrix</code> class represents a mathematical matrix. It provides methods for creating matrices, operating …\n"],["Matrix::EigenvalueDecomposition","","Matrix/EigenvalueDecomposition.html","","<p>Eigenvalues and eigenvectors of a real matrix.\n<p>Computes the eigenvalues and eigenvectors of a matrix  …\n"],["Matrix::LUPDecomposition","","Matrix/LUPDecomposition.html","","<p>For an m-by-n matrix A with m &gt;= n, the LU decomposition is an m-by-n unit lower triangular matrix …\n"],["Vector","","Vector.html","","<p>The <code>Vector</code> class represents a mathematical vector, which is useful in its own right, and also constitutes …\n"],["Vector::ZeroVectorError","","Vector/ZeroVectorError.html","",""],["*","Matrix","Matrix.html#method-i-2A","(m)","<p>Matrix multiplication.\n\n<pre>Matrix[[2,4], [6,8]] * Matrix.identity(2)\n  =&gt; 2 4\n     6 8</pre>\n"],["*","Vector","Vector.html#method-i-2A","(x)","<p>Multiplies the vector by <code>x</code>, where <code>x</code> is a number or a matrix.\n"],["**","Matrix","Matrix.html#method-i-2A-2A","(other)","<p>Matrix exponentiation. Equivalent to multiplying the matrix by itself N times. Non integer exponents …\n"],["+","Matrix","Matrix.html#method-i-2B","(m)","<p>Matrix addition.\n\n<pre>Matrix.scalar(2,5) + Matrix[[1,0], [-4,7]]\n  =&gt;  6  0\n     -4 12</pre>\n"],["+","Vector","Vector.html#method-i-2B","(v)","<p>Vector addition.\n"],["+@","Matrix","Matrix.html#method-i-2B-40","()",""],["+@","Vector","Vector.html#method-i-2B-40","()",""],["-","Matrix","Matrix.html#method-i-2D","(m)","<p>Matrix subtraction.\n\n<pre>Matrix[[1,5], [4,2]] - Matrix[[9,3], [-4,1]]\n  =&gt; -8  2\n      8  1</pre>\n"],["-","Vector","Vector.html#method-i-2D","(v)","<p>Vector subtraction.\n"],["-@","Matrix","Matrix.html#method-i-2D-40","()",""],["-@","Vector","Vector.html#method-i-2D-40","()",""],["/","Matrix","Matrix.html#method-i-2F","(other)","<p>Matrix division (multiplication by the inverse).\n\n<pre>Matrix[[7,6], [3,9]] / Matrix[[2,9], [3,1]]\n  =&gt; -7  ...</pre>\n"],["/","Vector","Vector.html#method-i-2F","(x)","<p>Vector division.\n"],["==","Matrix","Matrix.html#method-i-3D-3D","(other)","<p>Returns <code>true</code> if and only if the two matrices contain equal elements.\n"],["==","Vector","Vector.html#method-i-3D-3D","(other)","<p>Returns <code>true</code> iff the two vectors have the same elements in the same order.\n"],["I","Matrix","Matrix.html#method-c-I","(n)",""],["[]","Matrix","Matrix.html#method-c-5B-5D","(*rows)","<p>Creates a matrix where each argument is a row.\n\n<pre>Matrix[ [25, 93], [-1, 66] ]\n   =&gt;  25 93\n       -1 66</pre>\n"],["[]","Matrix","Matrix.html#method-i-5B-5D","(i, j)","<p>Returns element (<code>i</code>,<code>j</code>) of the matrix.  That is: row <code>i</code>, column <code>j</code>.\n"],["[]","Vector","Vector.html#method-c-5B-5D","(*array)","<p>Creates a Vector from a list of elements.\n\n<pre>Vector[7, 4, ...]</pre>\n"],["[]","Vector","Vector.html#method-i-5B-5D","(i)","<p>Returns element or elements of the vector.\n"],["[]=","Matrix","Matrix.html#method-i-5B-5D-3D","(i, j, v)","<p>Set element or elements of matrix.\n"],["[]=","Vector","Vector.html#method-i-5B-5D-3D","(i, v)","<p>Set element or elements of vector.\n"],["abs","Matrix","Matrix.html#method-i-abs","()","<p>Returns the absolute value elementwise\n"],["adjugate","Matrix","Matrix.html#method-i-adjugate","()","<p>Returns the adjugate of the matrix.\n\n<pre>Matrix[ [7,6],[3,9] ].adjugate\n  =&gt; 9 -6\n     -3 7</pre>\n"],["angle_with","Vector","Vector.html#method-i-angle_with","(v)","<p>Returns an angle with another vector. Result is within the [0..Math::PI].\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">Vector</span>[<span class=\"ruby-value\">1</span>,<span class=\"ruby-value\">0</span>].<span class=\"ruby-identifier\">angle_with</span>(<span class=\"ruby-constant\">Vector</span>[<span class=\"ruby-value\">0</span>,<span class=\"ruby-value\">1</span>]) <span class=\"ruby-operator\">...</span>\n</pre>\n"],["antisymmetric?","Matrix","Matrix.html#method-i-antisymmetric-3F","()","<p>Returns <code>true</code> if this is an antisymmetric matrix. Raises an error if matrix is not square.\n"],["basis","Vector","Vector.html#method-c-basis","(size:, index:)","<p>Returns a standard basis <code>n</code>-vector, where k is the index.\n\n<pre>Vector.basis(size:, index:) # =&gt; Vector[0, 1, ...</pre>\n"],["build","Matrix","Matrix.html#method-c-build","(row_count, column_count = row_count)","<p>Creates a matrix of size <code>row_count</code> x <code>column_count</code>. It fills the values by calling the given block, passing …\n"],["coerce","Matrix","Matrix.html#method-i-coerce","(other)","<p>The coerce method provides support for Ruby type coercion. This coercion mechanism is used by Ruby to …\n"],["coerce","Vector","Vector.html#method-i-coerce","(other)","<p>The coerce method provides support for Ruby type coercion. This coercion mechanism is used by Ruby to …\n"],["cofactor","Matrix","Matrix.html#method-i-cofactor","(row, column)","<p>Returns the (row, column) cofactor which is obtained by multiplying the first minor by (-1)**(row + column). …\n"],["cofactor_expansion","Matrix","Matrix.html#method-i-cofactor_expansion","(row: nil, column: nil)",""],["collect","Matrix","Matrix.html#method-i-collect","(which = :all)","<p>Returns a matrix that is the result of iteration of the given block over all elements of the matrix. …\n"],["collect","Vector","Vector.html#method-i-collect","()","<p>Like Array#collect.\n"],["collect!","Matrix","Matrix.html#method-i-collect-21","(which = :all)","<p>Invokes the given block for each element of matrix, replacing the element with the value returned by …\n"],["collect!","Vector","Vector.html#method-i-collect-21","(&block)","<p>Like Array#collect!\n"],["collect2","Vector","Vector.html#method-i-collect2","(v)","<p>Collects (as in Enumerable#collect) over the elements of this vector and <code>v</code> in conjunction.\n"],["column","Matrix","Matrix.html#method-i-column","(j)","<p>Returns column vector number <code>j</code> of the matrix as a Vector (starting at 0 like an array).  When a block …\n"],["column_vector","Matrix","Matrix.html#method-c-column_vector","(column)","<p>Creates a single-column matrix where the values of that column are as given in <code>column</code>.\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">Matrix</span>.<span class=\"ruby-identifier\">column_vector</span>([<span class=\"ruby-value\">4</span>,<span class=\"ruby-value\">5</span>,<span class=\"ruby-value\">6</span>]) <span class=\"ruby-operator\">...</span>\n</pre>\n"],["column_vectors","Matrix","Matrix.html#method-i-column_vectors","()","<p>Returns an array of the column vectors of the matrix.  See Vector.\n"],["columns","Matrix","Matrix.html#method-c-columns","(columns)","<p>Creates a matrix using <code>columns</code> as an array of column vectors.\n\n<pre>Matrix.columns([[25, 93], [-1, 66]])\n   ...</pre>\n"],["combine","Matrix","Matrix.html#method-c-combine","(*matrices)","<p>Create a matrix by combining matrices entrywise, using the given block\n\n<pre>x = Matrix[[6, 6], [4, 4]]\ny = ...</pre>\n"],["combine","Matrix","Matrix.html#method-i-combine","(*matrices, &block)",""],["component","Matrix","Matrix.html#method-i-component","(i, j)",""],["component","Vector","Vector.html#method-i-component","(i)",""],["conj","Matrix","Matrix.html#method-i-conj","()",""],["conjugate","Matrix","Matrix.html#method-i-conjugate","()","<p>Returns the conjugate of the matrix.\n\n<pre>Matrix[[Complex(1,2), Complex(0,1), 0], [1, 2, 3]]\n  =&gt; 1+2i   i ...</pre>\n"],["covector","Vector","Vector.html#method-i-covector","()","<p>Creates a single-row matrix from this vector.\n"],["cross","Vector","Vector.html#method-i-cross","(*vs)",""],["cross_product","Vector","Vector.html#method-i-cross_product","(*vs)","<p>Returns the cross product of this vector with the others.\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">Vector</span>[<span class=\"ruby-value\">1</span>, <span class=\"ruby-value\">0</span>, <span class=\"ruby-value\">0</span>].<span class=\"ruby-identifier\">cross_product</span> <span class=\"ruby-constant\">Vector</span>[<span class=\"ruby-value\">0</span>, <span class=\"ruby-value\">1</span>, <span class=\"ruby-value\">0</span>] <span class=\"ruby-operator\">...</span>\n</pre>\n"],["d","Matrix::EigenvalueDecomposition","Matrix/EigenvalueDecomposition.html#method-i-d","()",""],["det","Matrix","Matrix.html#method-i-det","()",""],["det","Matrix::LUPDecomposition","Matrix/LUPDecomposition.html#method-i-det","()","<p>Returns the determinant of <code>A</code>, calculated efficiently from the factorization.\n"],["det_e","Matrix","Matrix.html#method-i-det_e","()",""],["determinant","Matrix","Matrix.html#method-i-determinant","()","<p>Returns the determinant of the matrix.\n<p>Beware that using Float values can yield erroneous results because …\n"],["determinant","Matrix::LUPDecomposition","Matrix/LUPDecomposition.html#method-i-determinant","()",""],["determinant_e","Matrix","Matrix.html#method-i-determinant_e","()","<p>deprecated; use Matrix#determinant\n"],["diagonal","Matrix","Matrix.html#method-c-diagonal","(*values)","<p>Creates a matrix where the diagonal elements are composed of <code>values</code>.\n\n<pre>Matrix.diagonal(9, 5, -3)\n  =&gt;  9 ...</pre>\n"],["diagonal?","Matrix","Matrix.html#method-i-diagonal-3F","()","<p>Returns <code>true</code> if this is a diagonal matrix. Raises an error if matrix is not square.\n"],["dot","Vector","Vector.html#method-i-dot","(v)",""],["each","Matrix","Matrix.html#method-i-each","(which = :all)","<p>Yields all elements of the matrix, starting with those of the first row, or returns an Enumerator if …\n"],["each","Vector","Vector.html#method-i-each","(&block)","<p>Iterate over the elements of this vector\n"],["each2","Vector","Vector.html#method-i-each2","(v)","<p>Iterate over the elements of this vector and <code>v</code> in conjunction.\n"],["each_with_index","Matrix","Matrix.html#method-i-each_with_index","(which = :all)","<p>Same as #each, but the row index and column index in addition to the element\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">Matrix</span>[ [<span class=\"ruby-value\">1</span>,<span class=\"ruby-value\">2</span>], [<span class=\"ruby-value\">3</span>,<span class=\"ruby-value\">4</span>] ].<span class=\"ruby-identifier\">each_with_index</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["eigen","Matrix","Matrix.html#method-i-eigen","()",""],["eigensystem","Matrix","Matrix.html#method-i-eigensystem","()","<p>Returns the Eigensystem of the matrix; see <code>EigenvalueDecomposition</code>.\n\n<pre>m = Matrix[[1, 2], [3, 4]]\nv, d, v_inv ...</pre>\n"],["eigenvalue_matrix","Matrix::EigenvalueDecomposition","Matrix/EigenvalueDecomposition.html#method-i-eigenvalue_matrix","()","<p>Returns the block diagonal eigenvalue matrix <code>D</code>\n"],["eigenvalues","Matrix::EigenvalueDecomposition","Matrix/EigenvalueDecomposition.html#method-i-eigenvalues","()","<p>Returns the eigenvalues in an array\n"],["eigenvector_matrix","Matrix::EigenvalueDecomposition","Matrix/EigenvalueDecomposition.html#method-i-eigenvector_matrix","()","<p>Returns the eigenvector matrix <code>V</code>\n"],["eigenvector_matrix_inv","Matrix::EigenvalueDecomposition","Matrix/EigenvalueDecomposition.html#method-i-eigenvector_matrix_inv","()","<p>Returns the inverse of the eigenvector matrix <code>V</code>\n"],["eigenvectors","Matrix::EigenvalueDecomposition","Matrix/EigenvalueDecomposition.html#method-i-eigenvectors","()","<p>Returns an array of the eigenvectors\n"],["element","Matrix","Matrix.html#method-i-element","(i, j)",""],["element","Vector","Vector.html#method-i-element","(i)",""],["elements","Vector","Vector.html#method-c-elements","(array, copy = true)","<p>Creates a vector from an Array.  The optional second argument specifies whether the array itself or a …\n"],["elements_to_f","Matrix","Matrix.html#method-i-elements_to_f","()","<p>Deprecated.\n<p>Use map(&amp;:to_f)\n"],["elements_to_f","Vector","Vector.html#method-i-elements_to_f","()",""],["elements_to_i","Matrix","Matrix.html#method-i-elements_to_i","()","<p>Deprecated.\n<p>Use map(&amp;:to_i)\n"],["elements_to_i","Vector","Vector.html#method-i-elements_to_i","()",""],["elements_to_r","Matrix","Matrix.html#method-i-elements_to_r","()","<p>Deprecated.\n<p>Use map(&amp;:to_r)\n"],["elements_to_r","Vector","Vector.html#method-i-elements_to_r","()",""],["empty","Matrix","Matrix.html#method-c-empty","(row_count = 0, column_count = 0)","<p>Creates a empty matrix of <code>row_count</code> x <code>column_count</code>. At least one of <code>row_count</code> or <code>column_count</code> must be …\n"],["empty?","Matrix","Matrix.html#method-i-empty-3F","()","<p>Returns <code>true</code> if this is an empty matrix, i.e. if the number of rows or the number of columns is 0.\n"],["entrywise_product","Matrix","Matrix.html#method-i-entrywise_product","(m)",""],["eql?","Matrix","Matrix.html#method-i-eql-3F","(other)",""],["eql?","Vector","Vector.html#method-i-eql-3F","(other)",""],["find_index","Matrix","Matrix.html#method-i-find_index","(*args)",""],["first_minor","Matrix","Matrix.html#method-i-first_minor","(row, column)","<p>Returns the submatrix obtained by deleting the specified row and column.\n\n<pre>Matrix.diagonal(9, 5, -3, 4).first_minor(1, ...</pre>\n"],["freeze","Matrix","Matrix.html#method-i-freeze","()",""],["freeze","Vector","Vector.html#method-i-freeze","()",""],["hadamard_product","Matrix","Matrix.html#method-i-hadamard_product","(m)","<p>Hadamard product\n\n<pre>Matrix[[1,2], [3,4]].hadamard_product(Matrix[[1,2], [3,2]])\n  =&gt; 1  4\n     9  8</pre>\n"],["hash","Matrix","Matrix.html#method-i-hash","()","<p>Returns a hash-code for the matrix.\n"],["hash","Vector","Vector.html#method-i-hash","()","<p>Returns a hash-code for the vector.\n"],["hermitian?","Matrix","Matrix.html#method-i-hermitian-3F","()","<p>Returns <code>true</code> if this is an hermitian matrix. Raises an error if matrix is not square.\n"],["hstack","Matrix","Matrix.html#method-c-hstack","(x, *matrices)","<p>Create a matrix by stacking matrices horizontally\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">x</span> = <span class=\"ruby-constant\">Matrix</span>[[<span class=\"ruby-value\">1</span>, <span class=\"ruby-value\">2</span>], [<span class=\"ruby-value\">3</span>, <span class=\"ruby-value\">4</span>]]\n<span class=\"ruby-identifier\">y</span> = <span class=\"ruby-constant\">Matrix</span>[[<span class=\"ruby-value\">5</span>, <span class=\"ruby-value\">6</span>], [<span class=\"ruby-value\">7</span>, <span class=\"ruby-value\">8</span>]] <span class=\"ruby-operator\">...</span>\n</pre>\n"],["hstack","Matrix","Matrix.html#method-i-hstack","(*matrices)","<p>Returns a new matrix resulting by stacking horizontally the receiver with the given matrices\n\n<pre>x = Matrix[[1, ...</pre>\n"],["identity","Matrix","Matrix.html#method-c-identity","(n)","<p>Creates an <code>n</code> by <code>n</code> identity matrix.\n\n<pre>Matrix.identity(2)\n  =&gt; 1 0\n     0 1</pre>\n"],["imag","Matrix","Matrix.html#method-i-imag","()",""],["imaginary","Matrix","Matrix.html#method-i-imaginary","()","<p>Returns the imaginary part of the matrix.\n\n<pre>Matrix[[Complex(1,2), Complex(0,1), 0], [1, 2, 3]]\n  =&gt; 1+2i ...</pre>\n"],["independent?","Vector","Vector.html#method-c-independent-3F","(*vs)","<p>Returns <code>true</code> iff all of vectors are linearly independent.\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">Vector</span>.<span class=\"ruby-identifier\">independent?</span>(<span class=\"ruby-constant\">Vector</span>[<span class=\"ruby-value\">1</span>,<span class=\"ruby-value\">0</span>], <span class=\"ruby-constant\">Vector</span>[<span class=\"ruby-value\">0</span>,<span class=\"ruby-value\">1</span>]) <span class=\"ruby-operator\">...</span>\n</pre>\n"],["independent?","Vector","Vector.html#method-i-independent-3F","(*vs)","<p>Returns <code>true</code> iff all of vectors are linearly independent.\n\n<pre>Vector[1,0].independent?(Vector[0,1])\n  =&gt; true ...</pre>\n"],["index","Matrix","Matrix.html#method-i-index","(*args)","<p>The index method is specialized to return the index as [row, column] It also accepts an optional <code>selector</code> …\n"],["inner_product","Vector","Vector.html#method-i-inner_product","(v)","<p>Returns the inner product of this vector with the other.\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">Vector</span>[<span class=\"ruby-value\">4</span>,<span class=\"ruby-value\">7</span>].<span class=\"ruby-identifier\">inner_product</span> <span class=\"ruby-constant\">Vector</span>[<span class=\"ruby-value\">10</span>,<span class=\"ruby-value\">1</span>]  <span class=\"ruby-operator\">=&gt;</span> <span class=\"ruby-value\">47</span>\n</pre>\n"],["inspect","Matrix","Matrix.html#method-i-inspect","()","<p>Overrides Object#inspect\n"],["inspect","Vector","Vector.html#method-i-inspect","()","<p>Overrides Object#inspect\n"],["inv","Matrix","Matrix.html#method-i-inv","()",""],["inverse","Matrix","Matrix.html#method-i-inverse","()","<p>Returns the inverse of the matrix.\n\n<pre>Matrix[[-1, -1], [0, -1]].inverse\n  =&gt; -1  1\n      0 -1</pre>\n"],["l","Matrix::LUPDecomposition","Matrix/LUPDecomposition.html#method-i-l","()",""],["laplace_expansion","Matrix","Matrix.html#method-i-laplace_expansion","(row: nil, column: nil)","<p>Returns the Laplace expansion along given row or column.\n\n<pre>Matrix[[7,6], [3,9]].laplace_expansion(column: ...</pre>\n"],["lower_triangular?","Matrix","Matrix.html#method-i-lower_triangular-3F","()","<p>Returns <code>true</code> if this is a lower triangular matrix.\n"],["lup","Matrix","Matrix.html#method-i-lup","()","<p>Returns the LUP decomposition of the matrix; see <code>LUPDecomposition</code>.\n\n<pre>a = Matrix[[1, 2], [3, 4]]\nl, u, p ...</pre>\n"],["lup_decomposition","Matrix","Matrix.html#method-i-lup_decomposition","()",""],["magnitude","Vector","Vector.html#method-i-magnitude","()","<p>Returns the modulus (Pythagorean distance) of the vector.\n\n<pre>Vector[5,8,2].r =&gt; 9.643650761</pre>\n"],["map","Matrix","Matrix.html#method-i-map","(which = :all)",""],["map","Vector","Vector.html#method-i-map","()",""],["map!","Matrix","Matrix.html#method-i-map-21","(which = :all)",""],["map!","Vector","Vector.html#method-i-map-21","(&block)",""],["map2","Vector","Vector.html#method-i-map2","(v)","<p>Like Vector#collect2, but returns a Vector instead of an Array.\n"],["minor","Matrix","Matrix.html#method-i-minor","(*param)","<p>Returns a section of the matrix.  The parameters are either:\n<p>start_row, nrows, start_col, ncols; OR\n<p>row_range …\n"],["new","ExceptionForMatrix::ErrDimensionMismatch","ExceptionForMatrix/ErrDimensionMismatch.html#method-c-new","(val = nil)",""],["new","ExceptionForMatrix::ErrNotRegular","ExceptionForMatrix/ErrNotRegular.html#method-c-new","(val = nil)",""],["new","ExceptionForMatrix::ErrOperationNotDefined","ExceptionForMatrix/ErrOperationNotDefined.html#method-c-new","(vals)",""],["new","ExceptionForMatrix::ErrOperationNotImplemented","ExceptionForMatrix/ErrOperationNotImplemented.html#method-c-new","(vals)",""],["new","Matrix","Matrix.html#method-c-new","(rows, column_count = rows[0].size)","<p>Matrix.new is private; use Matrix.rows, columns, [], etc… to create.\n"],["new","Matrix::EigenvalueDecomposition","Matrix/EigenvalueDecomposition.html#method-c-new","(a)","<p>Constructs the eigenvalue decomposition for a square matrix <code>A</code>\n"],["new","Matrix::LUPDecomposition","Matrix/LUPDecomposition.html#method-c-new","(a)",""],["new","Vector","Vector.html#method-c-new","(array)","<p>Vector.new is private; use Vector[] or Vector.elements to create.\n"],["norm","Vector","Vector.html#method-i-norm","()",""],["normal?","Matrix","Matrix.html#method-i-normal-3F","()","<p>Returns <code>true</code> if this is a normal matrix. Raises an error if matrix is not square.\n"],["normalize","Vector","Vector.html#method-i-normalize","()","<p>Returns a new vector with the same direction but with norm 1.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">v</span> = <span class=\"ruby-constant\">Vector</span>[<span class=\"ruby-value\">5</span>,<span class=\"ruby-value\">8</span>,<span class=\"ruby-value\">2</span>].<span class=\"ruby-identifier\">normalize</span>\n<span class=\"ruby-comment\"># =&gt; Vector[0.5184758473652127, ...</span>\n</pre>\n"],["orthogonal?","Matrix","Matrix.html#method-i-orthogonal-3F","()","<p>Returns <code>true</code> if this is an orthogonal matrix Raises an error if matrix is not square.\n"],["p","Matrix::LUPDecomposition","Matrix/LUPDecomposition.html#method-i-p","()","<p>Returns the permutation matrix <code>P</code>\n"],["permutation?","Matrix","Matrix.html#method-i-permutation-3F","()","<p>Returns <code>true</code> if this is a permutation matrix Raises an error if matrix is not square.\n"],["r","Vector","Vector.html#method-i-r","()",""],["rank","Matrix","Matrix.html#method-i-rank","()","<p>Returns the rank of the matrix. Beware that using Float values can yield erroneous results because of …\n"],["rank_e","Matrix","Matrix.html#method-i-rank_e","()","<p>deprecated; use Matrix#rank\n"],["real","Matrix","Matrix.html#method-i-real","()","<p>Returns the real part of the matrix.\n\n<pre>Matrix[[Complex(1,2), Complex(0,1), 0], [1, 2, 3]]\n  =&gt; 1+2i  i  ...</pre>\n"],["real?","Matrix","Matrix.html#method-i-real-3F","()","<p>Returns <code>true</code> if all entries of the matrix are real.\n"],["rect","Matrix","Matrix.html#method-i-rect","()","<p>Returns an array containing matrices corresponding to the real and imaginary parts of the matrix\n<p>m.rect …\n"],["rectangular","Matrix","Matrix.html#method-i-rectangular","()",""],["regular?","Matrix","Matrix.html#method-i-regular-3F","()","<p>Returns <code>true</code> if this is a regular (i.e. non-singular) matrix.\n"],["round","Matrix","Matrix.html#method-i-round","(ndigits=0)","<p>Returns a matrix with entries rounded to the given precision (see Float#round)\n"],["round","Vector","Vector.html#method-i-round","(ndigits=0)","<p>Returns a vector with entries rounded to the given precision (see Float#round)\n"],["row","Matrix","Matrix.html#method-i-row","(i)","<p>Returns row vector number <code>i</code> of the matrix as a Vector (starting at 0 like an array).  When a block is …\n"],["row_count","Matrix","Matrix.html#method-i-row_count","()","<p>Returns the number of rows.\n"],["row_size","Matrix","Matrix.html#method-i-row_size","()",""],["row_vector","Matrix","Matrix.html#method-c-row_vector","(row)","<p>Creates a single-row matrix where the values of that row are as given in <code>row</code>.\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">Matrix</span>.<span class=\"ruby-identifier\">row_vector</span>([<span class=\"ruby-value\">4</span>,<span class=\"ruby-value\">5</span>,<span class=\"ruby-value\">6</span>]) <span class=\"ruby-operator\">...</span>\n</pre>\n"],["row_vectors","Matrix","Matrix.html#method-i-row_vectors","()","<p>Returns an array of the row vectors of the matrix.  See Vector.\n"],["rows","Matrix","Matrix.html#method-c-rows","(rows, copy = true)","<p>Creates a matrix where <code>rows</code> is an array of arrays, each of which is a row of the matrix.  If the optional …\n"],["scalar","Matrix","Matrix.html#method-c-scalar","(n, value)","<p>Creates an <code>n</code> by <code>n</code> diagonal matrix where each diagonal element is <code>value</code>.\n\n<pre>Matrix.scalar(2, 5)\n  =&gt; 5 0\n ...</pre>\n"],["singular?","Matrix","Matrix.html#method-i-singular-3F","()","<p>Returns <code>true</code> if this is a singular matrix.\n"],["singular?","Matrix::LUPDecomposition","Matrix/LUPDecomposition.html#method-i-singular-3F","()","<p>Returns <code>true</code> if <code>U</code>, and hence <code>A</code>, is singular.\n"],["size","Vector","Vector.html#method-i-size","()","<p>Returns the number of elements in the vector.\n"],["skew_symmetric?","Matrix","Matrix.html#method-i-skew_symmetric-3F","()",""],["solve","Matrix::LUPDecomposition","Matrix/LUPDecomposition.html#method-i-solve","(b)","<p>Returns <code>m</code> so that <code>A*m = b</code>, or equivalently so that <code>L*U*m = P*b</code> <code>b</code> can be a Matrix or a Vector\n"],["square?","Matrix","Matrix.html#method-i-square-3F","()","<p>Returns <code>true</code> if this is a square matrix.\n"],["symmetric?","Matrix","Matrix.html#method-i-symmetric-3F","()","<p>Returns <code>true</code> if this is a symmetric matrix. Raises an error if matrix is not square.\n"],["t","Matrix","Matrix.html#method-i-t","()",""],["to_a","Matrix","Matrix.html#method-i-to_a","()","<p>Returns an array of arrays that describe the rows of the matrix.\n"],["to_a","Matrix::EigenvalueDecomposition","Matrix/EigenvalueDecomposition.html#method-i-to_a","()",""],["to_a","Matrix::LUPDecomposition","Matrix/LUPDecomposition.html#method-i-to_a","()",""],["to_a","Vector","Vector.html#method-i-to_a","()","<p>Returns the elements of the vector in an array.\n"],["to_ary","Matrix::EigenvalueDecomposition","Matrix/EigenvalueDecomposition.html#method-i-to_ary","()","<p>Returns [eigenvector_matrix, eigenvalue_matrix, eigenvector_matrix_inv]\n"],["to_ary","Matrix::LUPDecomposition","Matrix/LUPDecomposition.html#method-i-to_ary","()","<p>Returns <code>L</code>, <code>U</code>, <code>P</code> in an array\n"],["to_matrix","Matrix","Matrix.html#method-i-to_matrix","()","<p>Explicit conversion to a Matrix. Returns self\n"],["to_matrix","Vector","Vector.html#method-i-to_matrix","()","<p>Return a single-column matrix from this vector\n"],["to_s","Matrix","Matrix.html#method-i-to_s","()","<p>Overrides Object#to_s\n"],["to_s","Vector","Vector.html#method-i-to_s","()","<p>Overrides Object#to_s\n"],["tr","Matrix","Matrix.html#method-i-tr","()",""],["trace","Matrix","Matrix.html#method-i-trace","()","<p>Returns the trace (sum of diagonal elements) of the matrix.\n\n<pre>Matrix[[7,6], [3,9]].trace\n  =&gt; 16</pre>\n"],["transpose","Matrix","Matrix.html#method-i-transpose","()","<p>Returns the transpose of the matrix.\n\n<pre>Matrix[[1,2], [3,4], [5,6]]\n  =&gt; 1 2\n     3 4\n     5 6\nMatrix[[1,2], ...</pre>\n"],["u","Matrix::LUPDecomposition","Matrix/LUPDecomposition.html#method-i-u","()","<p>Returns the upper triangular factor <code>U</code>\n"],["unit","Matrix","Matrix.html#method-c-unit","(n)",""],["unitary?","Matrix","Matrix.html#method-i-unitary-3F","()","<p>Returns <code>true</code> if this is a unitary matrix Raises an error if matrix is not square.\n"],["upper_triangular?","Matrix","Matrix.html#method-i-upper_triangular-3F","()","<p>Returns <code>true</code> if this is an upper triangular matrix.\n"],["v","Matrix::EigenvalueDecomposition","Matrix/EigenvalueDecomposition.html#method-i-v","()",""],["v_inv","Matrix::EigenvalueDecomposition","Matrix/EigenvalueDecomposition.html#method-i-v_inv","()",""],["vstack","Matrix","Matrix.html#method-c-vstack","(x, *matrices)","<p>Create a matrix by stacking matrices vertically\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">x</span> = <span class=\"ruby-constant\">Matrix</span>[[<span class=\"ruby-value\">1</span>, <span class=\"ruby-value\">2</span>], [<span class=\"ruby-value\">3</span>, <span class=\"ruby-value\">4</span>]]\n<span class=\"ruby-identifier\">y</span> = <span class=\"ruby-constant\">Matrix</span>[[<span class=\"ruby-value\">5</span>, <span class=\"ruby-value\">6</span>], [<span class=\"ruby-value\">7</span>, <span class=\"ruby-value\">8</span>]] <span class=\"ruby-operator\">...</span>\n</pre>\n"],["vstack","Matrix","Matrix.html#method-i-vstack","(*matrices)","<p>Returns a new matrix resulting by stacking vertically the receiver with the given matrices\n\n<pre>x = Matrix[[1, ...</pre>\n"],["zero","Matrix","Matrix.html#method-c-zero","(row_count, column_count = row_count)","<p>Creates a zero matrix.\n\n<pre>Matrix.zero(2)\n  =&gt; 0 0\n     0 0</pre>\n"],["zero","Vector","Vector.html#method-c-zero","(size)","<p>Return a zero vector.\n\n<pre>Vector.zero(3) =&gt; Vector[0, 0, 0]</pre>\n"],["zero?","Matrix","Matrix.html#method-i-zero-3F","()","<p>Returns <code>true</code> if this is a matrix with only zero elements\n"],["zero?","Vector","Vector.html#method-i-zero-3F","()","<p>Returns <code>true</code> iff all elements are zero.\n"]]}}