<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="https://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <!-- classpage -- >
    <!-- RD version: 0.42.0  -->
  <meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />
  <meta name='description' content='  Class : BigDecimal  -   Ruby 2.7.4 ' />
  <meta content="2021-12-08 17:16:34 -0700" http-equiv="change-date" />
  <!-- rel_prefix  = ''  ENV['RDOC_FOR_WEBSITE']   = false-->
    
    
    
  <!-- rel_prefix = '.'   asset_rel_prefix = ''  --> 
  <title>Class: BigDecimal (Ruby 2.7.4) </title>
  <link rel="stylesheet" href="css/associated.css" type="text/css" >
  <!-- link rel="stylesheet" href=".css/obf.css"  -->
  <link rel="stylesheet" href="css/inuit.css" >
  <link rel="stylesheet" href="css/grid.inuit.css" >
  <link rel="stylesheet" href="css/2011.css" type="text/css" >
  <link rel="stylesheet" href="css/rdoc.css" type="text/css" >
    <link rel="stylesheet" href="css/carbon17.css" type="text/css" >


  <script src="/js/jquery.js" type="text/javascript" charset="utf-8"></script>
  <script src="/js/thickbox-compressed.js" type="text/javascript" charset="utf-8"></script>
  <script src="/js/quicksearch.js" type="text/javascript" charset="utf-8"></script>
  <script src="/js/rubydoc.js" type="text/javascript" charset="utf-8"></script> 


   
<script src="/js/highlight.min.js"></script>
<script> 
  hljs.tabReplace = '  ';
  hljs.initHighlightingOnLoad();
  </script> 

  <style type='text/css'>

    #vulns-alert #vulns{
      background-color: #c33 ! important;
      width: 100%;
      text-align: center;
   }
   
   #vulns-alert #vulns a {
    color: #F99 ! important;
   }
 </style>

   <link rel="stylesheet" href="css/extra.css" type="text/css" >
  <script  src="/js/extra.js"  ></script>


</head>

<body id="top" class="class rdocstar">

<div id='actionbar' >
<div class='wrapper'>
  <ul class='grids g0'></ul>
</div>
<span id='vulns-alert'></span>
<!-- VERSION HEADER for 2.7.4 NOT FOUND -->
</div> <!-- end action bar -->
 <div class='wrapper'>
  
   <!-- carbon17 added here 2017-09-09 -->
 

   <div id="metadata">
    <div id="home-metadata">
      <div id="home-section" class="section">
        <h3 class="section-header">
          <a href="./index.html">Home</a>
          <a href="./index.html#classes">Classes</a>
          <a href="./index.html#methods">Methods</a>
          
        </h3>
      </div>
    </div>

    <div id="file-metadata">
      <div id="file-list-section" class="section">
        <h3 class="section-header">In Files</h3>
        <div class="section-body">
          <ul id='file-metadata'>

          
          
          
          <li class='in-file'>bigdecimal/bigdecimal.c</li>      
            
          
          <li class='in-file'>bigdecimal/lib/bigdecimal/util.rb</li>      
            
          </ul>
        </div>
      </div>

      
    </div>

    <div id="class-metadata">
      
      <!-- Parent Class -->
      <div id="parent-class-section" class="section">
        <h3 class="section-header">Parent</h3>
        
        <p class="link">Numeric</p>
        
      </div>
      

      

      

      
      <!-- Method Quickref -->
      <div id="method-list-section" class="section">
        <h3 class="section-header">Methods</h3>
        <ul class="link-list">
          
          <li><a href="#method-c-_load">::_load</a></li>
          
          <li><a href="#method-c-double_fig">::double_fig</a></li>
          
          <li><a href="#method-c-interpret_loosely">::interpret_loosely</a></li>
          
          <li><a href="#method-c-limit">::limit</a></li>
          
          <li><a href="#method-c-mode">::mode</a></li>
          
          <li><a href="#method-c-save_exception_mode">::save_exception_mode</a></li>
          
          <li><a href="#method-c-save_limit">::save_limit</a></li>
          
          <li><a href="#method-c-save_rounding_mode">::save_rounding_mode</a></li>
          
          <li><a href="#method-i-25">#%</a></li>
          
          <li><a href="#method-i-2A">#*</a></li>
          
          <li><a href="#method-i-2A-2A">#**</a></li>
          
          <li><a href="#method-i-2B">#+</a></li>
          
          <li><a href="#method-i-2B-40">#+@</a></li>
          
          <li><a href="#method-i-2D">#-</a></li>
          
          <li><a href="#method-i-2D-40">#-@</a></li>
          
          <li><a href="#method-i-2F">#/</a></li>
          
          <li><a href="#method-i-3C">#<</a></li>
          
          <li><a href="#method-i-3C-3D">#<=</a></li>
          
          <li><a href="#method-i-3C-3D-3E">#<=></a></li>
          
          <li><a href="#method-i-3D-3D">#==</a></li>
          
          <li><a href="#method-i-3D-3D-3D">#===</a></li>
          
          <li><a href="#method-i-3E">#></a></li>
          
          <li><a href="#method-i-3E-3D">#>=</a></li>
          
          <li><a href="#method-i-_dump">#_dump</a></li>
          
          <li><a href="#method-i-abs">#abs</a></li>
          
          <li><a href="#method-i-add">#add</a></li>
          
          <li><a href="#method-i-ceil">#ceil</a></li>
          
          <li><a href="#method-i-clone">#clone</a></li>
          
          <li><a href="#method-i-coerce">#coerce</a></li>
          
          <li><a href="#method-i-div">#div</a></li>
          
          <li><a href="#method-i-divmod">#divmod</a></li>
          
          <li><a href="#method-i-dup">#dup</a></li>
          
          <li><a href="#method-i-eql-3F">#eql?</a></li>
          
          <li><a href="#method-i-exponent">#exponent</a></li>
          
          <li><a href="#method-i-finite-3F">#finite?</a></li>
          
          <li><a href="#method-i-fix">#fix</a></li>
          
          <li><a href="#method-i-floor">#floor</a></li>
          
          <li><a href="#method-i-frac">#frac</a></li>
          
          <li><a href="#method-i-hash">#hash</a></li>
          
          <li><a href="#method-i-infinite-3F">#infinite?</a></li>
          
          <li><a href="#method-i-inspect">#inspect</a></li>
          
          <li><a href="#method-i-modulo">#modulo</a></li>
          
          <li><a href="#method-i-mult">#mult</a></li>
          
          <li><a href="#method-i-nan-3F">#nan?</a></li>
          
          <li><a href="#method-i-nonzero-3F">#nonzero?</a></li>
          
          <li><a href="#method-i-power">#power</a></li>
          
          <li><a href="#method-i-precs">#precs</a></li>
          
          <li><a href="#method-i-quo">#quo</a></li>
          
          <li><a href="#method-i-remainder">#remainder</a></li>
          
          <li><a href="#method-i-round">#round</a></li>
          
          <li><a href="#method-i-sign">#sign</a></li>
          
          <li><a href="#method-i-split">#split</a></li>
          
          <li><a href="#method-i-sqrt">#sqrt</a></li>
          
          <li><a href="#method-i-sub">#sub</a></li>
          
          <li><a href="#method-i-to_d">#to_d</a></li>
          
          <li><a href="#method-i-to_digits">#to_digits</a></li>
          
          <li><a href="#method-i-to_f">#to_f</a></li>
          
          <li><a href="#method-i-to_i">#to_i</a></li>
          
          <li><a href="#method-i-to_int">#to_int</a></li>
          
          <li><a href="#method-i-to_r">#to_r</a></li>
          
          <li><a href="#method-i-to_s">#to_s</a></li>
          
          <li><a href="#method-i-truncate">#truncate</a></li>
          
          <li><a href="#method-i-zero-3F">#zero?</a></li>
          
        </ul>
      </div>
      

      
    </div>

    <div id="project-metadata">
      
      

      <div id="classindex-section" class="section project-section">
        <h3 class="section-header">Class/Module Index
          <span class="search-toggle"><img src="./images/find.png"
            height="16" width="16" alt="[+]"
            title="show/hide quicksearch" /></span></h3>
        <form action="#" method="get" accept-charset="utf-8" class="initially-hidden">
        <fieldset>
          <legend>Quicksearch</legend>
          <input type="text" name="quicksearch" value=""
            class="quicksearch-field" />
        </fieldset>
        </form>

        <ul class="link-list">
          
          
          
          <li><a href="./BigDecimal.html">BigDecimal</a></li>
        
          
          
          <li><a href="./BigMath.html">BigMath</a></li>
        
          
          
          <li><a href="./Float.html">Float</a></li>
        
          
          
          <li><a href="./Integer.html">Integer</a></li>
        
          
          
          <li><a href="./Jacobian.html">Jacobian</a></li>
        
          
          
          <li><a href="./Kernel.html">Kernel</a></li>
        
          
          
          <li><a href="./LUSolve.html">LUSolve</a></li>
        
          
          
          <li><a href="./Newton.html">Newton</a></li>
        
          
          
          <li><a href="./NilClass.html">NilClass</a></li>
        
          
          
          <li><a href="./Rational.html">Rational</a></li>
        
          
          
          <li><a href="./String.html">String</a></li>
        
        </ul>
        <div id="no-class-search-results" style="display: none;">No matching classes.</div>
      </div>

      
    </div>
  </div> <!-- metadata -->
  <div class='adzbox'  id="azk83167">
    
  </div> 
  <div id="documentation">
    <h1 class="class">BigDecimal</h1>

    <div id="description" class="description">
      
<p><a href="BigDecimal.html"><code>BigDecimal</code></a> provides arbitrary-precision floating point decimal arithmetic.</p>

<h2 id="class-BigDecimal-label-Introduction">Introduction<span><a href="#class-BigDecimal-label-Introduction">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Ruby provides built-in support for arbitrary precision integer arithmetic.</p>

<p>For example:</p>

<pre class="ruby"><span class="ruby-value">42</span><span class="ruby-operator">**</span><span class="ruby-value">13</span>  <span class="ruby-comment">#=&gt;   1265437718438866624512</span>
</pre>

<p><a href="BigDecimal.html"><code>BigDecimal</code></a> provides similar support for very large or very accurate floating point numbers.</p>

<p>Decimal arithmetic is also useful for general calculation, because it provides the correct answers people expectâ€“whereas normal binary floating point arithmetic often introduces subtle errors because of the conversion between base 10 and base 2.</p>

<p>For example, try:</p>

<pre class="ruby"><span class="ruby-identifier">sum</span> = <span class="ruby-value">0</span>
<span class="ruby-value">10_000</span>.<span class="ruby-identifier">times</span> <span class="ruby-keyword">do</span>
  <span class="ruby-identifier">sum</span> = <span class="ruby-identifier">sum</span> <span class="ruby-operator">+</span> <span class="ruby-value">0.0001</span>
<span class="ruby-keyword">end</span>
<span class="ruby-identifier">print</span> <span class="ruby-identifier">sum</span> <span class="ruby-comment">#=&gt; 0.9999999999999062</span>
</pre>

<p>and contrast with the output from:</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&#39;bigdecimal&#39;</span>

<span class="ruby-identifier">sum</span> = <span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&quot;0&quot;</span>)
<span class="ruby-value">10_000</span>.<span class="ruby-identifier">times</span> <span class="ruby-keyword">do</span>
  <span class="ruby-identifier">sum</span> = <span class="ruby-identifier">sum</span> <span class="ruby-operator">+</span> <span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&quot;0.0001&quot;</span>)
<span class="ruby-keyword">end</span>
<span class="ruby-identifier">print</span> <span class="ruby-identifier">sum</span> <span class="ruby-comment">#=&gt; 0.1E1</span>
</pre>

<p>Similarly:</p>

<pre class="ruby">(<span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&quot;1.2&quot;</span>) <span class="ruby-operator">-</span> <span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&quot;1.0&quot;</span>)) <span class="ruby-operator">==</span> <span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&quot;0.2&quot;</span>) <span class="ruby-comment">#=&gt; true</span>

(<span class="ruby-value">1.2</span> <span class="ruby-operator">-</span> <span class="ruby-value">1.0</span>) <span class="ruby-operator">==</span> <span class="ruby-value">0.2</span> <span class="ruby-comment">#=&gt; false</span>
</pre>

<h2 id="class-BigDecimal-label-Special+features+of+accurate+decimal+arithmetic">Special features of accurate decimal arithmetic<span><a href="#class-BigDecimal-label-Special+features+of+accurate+decimal+arithmetic">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Because <a href="BigDecimal.html"><code>BigDecimal</code></a> is more accurate than normal binary floating point arithmetic, it requires some special values.</p>

<h3 id="class-BigDecimal-label-Infinity">Infinity<span><a href="#class-BigDecimal-label-Infinity">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p><a href="BigDecimal.html"><code>BigDecimal</code></a> sometimes needs to return infinity, for example if you divide a value by zero.</p>

<pre class="ruby"><span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&quot;1.0&quot;</span>) <span class="ruby-operator">/</span> <span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&quot;0.0&quot;</span>)  <span class="ruby-comment">#=&gt; Infinity</span>
<span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&quot;-1.0&quot;</span>) <span class="ruby-operator">/</span> <span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&quot;0.0&quot;</span>)  <span class="ruby-comment">#=&gt; -Infinity</span>
</pre>

<p>You can represent infinite numbers to <a href="BigDecimal.html"><code>BigDecimal</code></a> using the strings <code>&#39;Infinity&#39;</code>, <code>&#39;+Infinity&#39;</code> and <code>&#39;-Infinity&#39;</code> (case-sensitive)</p>

<h3 id="class-BigDecimal-label-Not+a+Number">Not a Number<span><a href="#class-BigDecimal-label-Not+a+Number">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>When a computation results in an undefined value, the special value <code>NaN</code> (for &#39;not a number&#39;) is returned.</p>

<p>Example:</p>

<pre class="ruby"><span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&quot;0.0&quot;</span>) <span class="ruby-operator">/</span> <span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&quot;0.0&quot;</span>) <span class="ruby-comment">#=&gt; NaN</span>
</pre>

<p>You can also create undefined values.</p>

<p>NaN is never considered to be the same as any other value, even NaN itself:</p>

<pre class="ruby"><span class="ruby-identifier">n</span> = <span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&#39;NaN&#39;</span>)
<span class="ruby-identifier">n</span> <span class="ruby-operator">==</span> <span class="ruby-value">0.0</span> <span class="ruby-comment">#=&gt; false</span>
<span class="ruby-identifier">n</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">n</span> <span class="ruby-comment">#=&gt; false</span>
</pre>

<h3 id="class-BigDecimal-label-Positive+and+negative+zero">Positive and negative zero<span><a href="#class-BigDecimal-label-Positive+and+negative+zero">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>If a computation results in a value which is too small to be represented as a <a href="BigDecimal.html"><code>BigDecimal</code></a> within the currently specified limits of precision, zero must be returned.</p>

<p>If the value which is too small to be represented is negative, a <a href="BigDecimal.html"><code>BigDecimal</code></a> value of negative zero is returned.</p>

<pre class="ruby"><span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&quot;1.0&quot;</span>) <span class="ruby-operator">/</span> <span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&quot;-Infinity&quot;</span>) <span class="ruby-comment">#=&gt; -0.0</span>
</pre>

<p>If the value is positive, a value of positive zero is returned.</p>

<pre class="ruby"><span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&quot;1.0&quot;</span>) <span class="ruby-operator">/</span> <span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&quot;Infinity&quot;</span>) <span class="ruby-comment">#=&gt; 0.0</span>
</pre>

<p>(See <a href="BigDecimal.html#method-c-mode"><code>BigDecimal.mode</code></a> for how to specify limits of precision.)</p>

<p>Note that <code>-0.0</code> and <code>0.0</code> are considered to be the same for the purposes of comparison.</p>

<p>Note also that in mathematics, there is no particular concept of negative or positive zero; true mathematical zero has no sign.</p>

<h2 id="class-BigDecimal-label-bigdecimal-2Futil">bigdecimal/util<span><a href="#class-BigDecimal-label-bigdecimal-2Futil">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>When you require <code>bigdecimal/util</code>, the <a href="BigDecimal.html#method-i-to_d"><code>to_d</code></a> method will be available on <a href="BigDecimal.html"><code>BigDecimal</code></a> and the native <a href="Integer.html"><code>Integer</code></a>, <a href="Float.html"><code>Float</code></a>, <a href="Rational.html"><code>Rational</code></a>, and <a href="String.html"><code>String</code></a> classes:</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&#39;bigdecimal/util&#39;</span>

<span class="ruby-value">42</span>.<span class="ruby-identifier">to_d</span>         <span class="ruby-comment"># =&gt; 0.42e2</span>
<span class="ruby-value">0.5</span>.<span class="ruby-identifier">to_d</span>        <span class="ruby-comment"># =&gt; 0.5e0</span>
(<span class="ruby-value">2</span><span class="ruby-operator">/</span><span class="ruby-value">3r</span>).<span class="ruby-identifier">to_d</span>(<span class="ruby-value">3</span>)  <span class="ruby-comment"># =&gt; 0.667e0</span>
<span class="ruby-string">&quot;0.5&quot;</span>.<span class="ruby-identifier">to_d</span>      <span class="ruby-comment"># =&gt; 0.5e0</span>
</pre>

<h2 id="class-BigDecimal-label-License">License<span><a href="#class-BigDecimal-label-License">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Copyright (C) 2002 by Shigeo Kobayashi &lt;shigeo@tinyforest.gr.jp&gt;.</p>

<p><a href="BigDecimal.html"><code>BigDecimal</code></a> is released under the Ruby and 2-clause BSD licenses. See LICENSE.txt for details.</p>

<p>Maintained by mrkn &lt;mrkn@mrkn.jp&gt; and ruby-core members.</p>

<p>Documented by zzak &lt;zachary@zacharyscott.net&gt;, mathew &lt;meta@pobox.com&gt;, and many other contributors.</p>

    </div><!-- description -->

    
    
    
    <div id="5Buntitled-5D" class="documentation-section">
      

      

      
      <!-- Constants -->
      <div id="constants-list" class="section">
        <h3 class="section-header">Constants</h3>
        <dl>
        
          <dt><a name="BASE">BASE</a></dt>
          
          <dd class="description"><p>Base value used in internal calculations.  On a 32 bit system, <a href="BigDecimal.html#BASE"><code>BASE</code></a> is 10000, indicating that calculation is done in groups of 4 digits. (If it were larger, BASE**2 wouldn&#39;t fit in 32 bits, so you couldn&#39;t guarantee that two groups could always be multiplied together without overflow.)</p></dd>
          
        
          <dt><a name="EXCEPTION_ALL">EXCEPTION_ALL</a></dt>
          
          <dd class="description"><p>Determines whether overflow, underflow or zero divide result in an exception being thrown. See <a href="BigDecimal.html#method-c-mode"><code>BigDecimal.mode</code></a>.</p></dd>
          
        
          <dt><a name="EXCEPTION_INFINITY">EXCEPTION_INFINITY</a></dt>
          
          <dd class="description"><p>Determines what happens when the result of a computation is infinity.  See <a href="BigDecimal.html#method-c-mode"><code>BigDecimal.mode</code></a>.</p></dd>
          
        
          <dt><a name="EXCEPTION_NaN">EXCEPTION_NaN</a></dt>
          
          <dd class="description"><p>Determines what happens when the result of a computation is not a number (NaN). See <a href="BigDecimal.html#method-c-mode"><code>BigDecimal.mode</code></a>.</p></dd>
          
        
          <dt><a name="EXCEPTION_OVERFLOW">EXCEPTION_OVERFLOW</a></dt>
          
          <dd class="description"><p>Determines what happens when the result of a computation is an overflow (a result too large to be represented). See <a href="BigDecimal.html#method-c-mode"><code>BigDecimal.mode</code></a>.</p></dd>
          
        
          <dt><a name="EXCEPTION_UNDERFLOW">EXCEPTION_UNDERFLOW</a></dt>
          
          <dd class="description"><p>Determines what happens when the result of a computation is an underflow (a result too small to be represented). See <a href="BigDecimal.html#method-c-mode"><code>BigDecimal.mode</code></a>.</p></dd>
          
        
          <dt><a name="EXCEPTION_ZERODIVIDE">EXCEPTION_ZERODIVIDE</a></dt>
          
          <dd class="description"><p>Determines what happens when a division by zero is performed. See <a href="BigDecimal.html#method-c-mode"><code>BigDecimal.mode</code></a>.</p></dd>
          
        
          <dt><a name="INFINITY">INFINITY</a></dt>
          
          <dd class="description"><p>Positive infinity value.</p></dd>
          
        
          <dt><a name="NAN">NAN</a></dt>
          
          <dd class="description"><p>&#39;Not a Number&#39; value.</p></dd>
          
        
          <dt><a name="ROUND_CEILING">ROUND_CEILING</a></dt>
          
          <dd class="description"><p>Round towards +Infinity. See <a href="BigDecimal.html#method-c-mode"><code>BigDecimal.mode</code></a>.</p></dd>
          
        
          <dt><a name="ROUND_DOWN">ROUND_DOWN</a></dt>
          
          <dd class="description"><p>Indicates that values should be rounded towards zero. See <a href="BigDecimal.html#method-c-mode"><code>BigDecimal.mode</code></a>.</p></dd>
          
        
          <dt><a name="ROUND_FLOOR">ROUND_FLOOR</a></dt>
          
          <dd class="description"><p>Round towards -Infinity. See <a href="BigDecimal.html#method-c-mode"><code>BigDecimal.mode</code></a>.</p></dd>
          
        
          <dt><a name="ROUND_HALF_DOWN">ROUND_HALF_DOWN</a></dt>
          
          <dd class="description"><p>Indicates that digits &gt;= 6 should be rounded up, others rounded down. See <a href="BigDecimal.html#method-c-mode"><code>BigDecimal.mode</code></a>.</p></dd>
          
        
          <dt><a name="ROUND_HALF_EVEN">ROUND_HALF_EVEN</a></dt>
          
          <dd class="description"><p>Round towards the even neighbor. See <a href="BigDecimal.html#method-c-mode"><code>BigDecimal.mode</code></a>.</p></dd>
          
        
          <dt><a name="ROUND_HALF_UP">ROUND_HALF_UP</a></dt>
          
          <dd class="description"><p>Indicates that digits &gt;= 5 should be rounded up, others rounded down. See <a href="BigDecimal.html#method-c-mode"><code>BigDecimal.mode</code></a>.</p></dd>
          
        
          <dt><a name="ROUND_MODE">ROUND_MODE</a></dt>
          
          <dd class="description"><p>Determines what happens when a result must be rounded in order to fit in the appropriate number of significant digits. See <a href="BigDecimal.html#method-c-mode"><code>BigDecimal.mode</code></a>.</p></dd>
          
        
          <dt><a name="ROUND_UP">ROUND_UP</a></dt>
          
          <dd class="description"><p>Indicates that values should be rounded away from zero. See <a href="BigDecimal.html#method-c-mode"><code>BigDecimal.mode</code></a>.</p></dd>
          
        
          <dt><a name="SIGN_NEGATIVE_FINITE">SIGN_NEGATIVE_FINITE</a></dt>
          
          <dd class="description"><p>Indicates that a value is negative and finite. See <a href="BigDecimal.html#method-i-sign"><code>BigDecimal.sign</code></a>.</p></dd>
          
        
          <dt><a name="SIGN_NEGATIVE_INFINITE">SIGN_NEGATIVE_INFINITE</a></dt>
          
          <dd class="description"><p>Indicates that a value is negative and infinite. See <a href="BigDecimal.html#method-i-sign"><code>BigDecimal.sign</code></a>.</p></dd>
          
        
          <dt><a name="SIGN_NEGATIVE_ZERO">SIGN_NEGATIVE_ZERO</a></dt>
          
          <dd class="description"><p>Indicates that a value is -0. See <a href="BigDecimal.html#method-i-sign"><code>BigDecimal.sign</code></a>.</p></dd>
          
        
          <dt><a name="SIGN_NaN">SIGN_NaN</a></dt>
          
          <dd class="description"><p>Indicates that a value is not a number. See <a href="BigDecimal.html#method-i-sign"><code>BigDecimal.sign</code></a>.</p></dd>
          
        
          <dt><a name="SIGN_POSITIVE_FINITE">SIGN_POSITIVE_FINITE</a></dt>
          
          <dd class="description"><p>Indicates that a value is positive and finite. See <a href="BigDecimal.html#method-i-sign"><code>BigDecimal.sign</code></a>.</p></dd>
          
        
          <dt><a name="SIGN_POSITIVE_INFINITE">SIGN_POSITIVE_INFINITE</a></dt>
          
          <dd class="description"><p>Indicates that a value is positive and infinite. See <a href="BigDecimal.html#method-i-sign"><code>BigDecimal.sign</code></a>.</p></dd>
          
        
          <dt><a name="SIGN_POSITIVE_ZERO">SIGN_POSITIVE_ZERO</a></dt>
          
          <dd class="description"><p>Indicates that a value is +0. See <a href="BigDecimal.html#method-i-sign"><code>BigDecimal.sign</code></a>.</p></dd>
          
        
          <dt><a name="VERSION">VERSION</a></dt>
          
          <dd class="description"><p>The version of bigdecimal library</p></dd>
          
        
        </dl>
      </div>
      

      

      <!-- Methods -->
      
      <div id="public-class-method-details" class="method-section section">
        <h3 class="section-header">Public Class Methods</h3>

      
        <div id="_load-method" class="method-detail ">
          <a name="method-c-_load"></a>

          
          <div class="method-heading">
            <span class="method-name">_load</span><span
              class="method-args">(p1)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          
          <div>
  
            
            <p>Internal method used to provide marshalling support. See the Marshal module.</p>
            

            
            <div class="method-source-code" id="_load-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
BigDecimal_load(VALUE self, VALUE str)
{
    ENTER(2);
    Real *pv;
    unsigned char *pch;
    unsigned char ch;
    unsigned long m=0;

    pch = (unsigned char *)StringValueCStr(str);
    /* First get max prec */
    while((*pch) != (unsigned char)&#39;\0&#39; &amp;&amp; (ch = *pch++) != (unsigned char)&#39;:&#39;) {
        if(!ISDIGIT(ch)) {
            rb_raise(rb_eTypeError, &quot;load failed: invalid character in the marshaled string&quot;);
        }
        m = m*10 + (unsigned long)(ch-&#39;0&#39;);
    }
    if (m &gt; VpBaseFig()) m -= VpBaseFig();
    GUARD_OBJ(pv, VpNewRbClass(m, (char *)pch, self));
    m /= VpBaseFig();
    if (m &amp;&amp; pv-&gt;MaxPrec &gt; m) {
        pv-&gt;MaxPrec = m+1;
    }
    return ToValue(pv);
}
            </pre> 
            </div><!-- _load-source -->
            
          </div>

          

          
        </div><!-- _load-method -->
      
        <div id="double_fig-method" class="method-detail ">
          <a name="method-c-double_fig"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">double_fig</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>The <a href="BigDecimal.html#method-c-double_fig"><code>BigDecimal.double_fig</code></a> class method returns the number of digits a <a href="Float.html"><code>Float</code></a> number is allowed to have. The result depends upon the CPU and OS in use.</p>
            

            
            <div class="method-source-code" id="double_fig-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
BigDecimal_double_fig(VALUE self)
{
    return INT2FIX(VpDblFig());
}
            </pre> 
            </div><!-- double_fig-source -->
            
          </div>

          

          
        </div><!-- double_fig-method -->
      
        <div id="interpret_loosely-method" class="method-detail ">
          <a name="method-c-interpret_loosely"></a>

          
          <div class="method-heading">
            <span class="method-name">interpret_loosely</span><span
              class="method-args">(p1)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          
          <div>
  
            
            
            

            
            <div class="method-source-code" id="interpret_loosely-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
BigDecimal_s_interpret_loosely(VALUE klass, VALUE str)
{
    ENTER(1);
    char const *c_str;
    Real *pv;

    c_str = StringValueCStr(str);
    GUARD_OBJ(pv, VpAlloc(0, c_str, 0, 1));
    pv-&gt;obj = TypedData_Wrap_Struct(klass, &amp;BigDecimal_data_type, pv);
    RB_OBJ_FREEZE(pv-&gt;obj);
    return pv-&gt;obj;
}
            </pre> 
            </div><!-- interpret_loosely-source -->
            
          </div>

          

          
        </div><!-- interpret_loosely-method -->
      
        <div id="limit-method" class="method-detail ">
          <a name="method-c-limit"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">limit(digits)</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Limit the number of significant digits in newly created <a href="BigDecimal.html"><code>BigDecimal</code></a> numbers to the specified value. Rounding is performed as necessary, as specified by <a href="BigDecimal.html#method-c-mode"><code>BigDecimal.mode</code></a>.</p>

<p>A limit of 0, the default, means no upper limit.</p>

<p>The limit specified by this method takes less priority over any limit specified to instance methods such as ceil, floor, truncate, or round.</p>
            

            
            <div class="method-source-code" id="limit-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
BigDecimal_limit(int argc, VALUE *argv, VALUE self)
{
    VALUE  nFig;
    VALUE  nCur = INT2NUM(VpGetPrecLimit());

    if (rb_scan_args(argc, argv, &quot;01&quot;, &amp;nFig) == 1) {
        int nf;
        if (NIL_P(nFig)) return nCur;
        nf = NUM2INT(nFig);
        if (nf &lt; 0) {
            rb_raise(rb_eArgError, &quot;argument must be positive&quot;);
        }
        VpSetPrecLimit(nf);
    }
    return nCur;
}
            </pre> 
            </div><!-- limit-source -->
            
          </div>

          

          
        </div><!-- limit-method -->
      
        <div id="mode-method" class="method-detail ">
          <a name="method-c-mode"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">mode(mode, value)</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Controls handling of arithmetic exceptions and rounding. If no value is supplied, the current value is returned.</p>

<p>Six values of the mode parameter control the handling of arithmetic exceptions:</p>

<p><a href="BigDecimal.html#EXCEPTION_NaN"><code>BigDecimal::EXCEPTION_NaN</code></a> <a href="BigDecimal.html#EXCEPTION_INFINITY"><code>BigDecimal::EXCEPTION_INFINITY</code></a> <a href="BigDecimal.html#EXCEPTION_UNDERFLOW"><code>BigDecimal::EXCEPTION_UNDERFLOW</code></a> <a href="BigDecimal.html#EXCEPTION_OVERFLOW"><code>BigDecimal::EXCEPTION_OVERFLOW</code></a> <a href="BigDecimal.html#EXCEPTION_ZERODIVIDE"><code>BigDecimal::EXCEPTION_ZERODIVIDE</code></a> <a href="BigDecimal.html#EXCEPTION_ALL"><code>BigDecimal::EXCEPTION_ALL</code></a></p>

<p>For each mode parameter above, if the value set is false, computation continues after an arithmetic exception of the appropriate type. When computation continues, results are as follows:</p>
<dl class="rdoc-list note-list"><dt><a href="BigDecimal.html#EXCEPTION_NaN"><code>EXCEPTION_NaN</code></a>
<dd>
<p>NaN</p>
</dd><dt><a href="BigDecimal.html#EXCEPTION_INFINITY"><code>EXCEPTION_INFINITY</code></a>
<dd>
<p>+Infinity or -Infinity</p>
</dd><dt><a href="BigDecimal.html#EXCEPTION_UNDERFLOW"><code>EXCEPTION_UNDERFLOW</code></a>
<dd>
<p>0</p>
</dd><dt><a href="BigDecimal.html#EXCEPTION_OVERFLOW"><code>EXCEPTION_OVERFLOW</code></a>
<dd>
<p>+Infinity or -Infinity</p>
</dd><dt><a href="BigDecimal.html#EXCEPTION_ZERODIVIDE"><code>EXCEPTION_ZERODIVIDE</code></a>
<dd>
<p>+Infinity or -Infinity</p>
</dd></dl>

<p>One value of the mode parameter controls the rounding of numeric values: <a href="BigDecimal.html#ROUND_MODE"><code>BigDecimal::ROUND_MODE</code></a>. The values it can take are:</p>
<dl class="rdoc-list note-list"><dt><a href="BigDecimal.html#ROUND_UP"><code>ROUND_UP</code></a>, :up
<dd>
<p>round away from zero</p>
</dd><dt><a href="BigDecimal.html#ROUND_DOWN"><code>ROUND_DOWN</code></a>, :down, :truncate
<dd>
<p>round towards zero (truncate)</p>
</dd><dt><a href="BigDecimal.html#ROUND_HALF_UP"><code>ROUND_HALF_UP</code></a>, :half_up, :default
<dd>
<p>round towards the nearest neighbor, unless both neighbors are equidistant, in which case round away from zero. (default)</p>
</dd><dt><a href="BigDecimal.html#ROUND_HALF_DOWN"><code>ROUND_HALF_DOWN</code></a>, :half_down
<dd>
<p>round towards the nearest neighbor, unless both neighbors are equidistant, in which case round towards zero.</p>
</dd><dt><a href="BigDecimal.html#ROUND_HALF_EVEN"><code>ROUND_HALF_EVEN</code></a>, :half_even, :banker
<dd>
<p>round towards the nearest neighbor, unless both neighbors are equidistant, in which case round towards the even neighbor (Banker&#39;s rounding)</p>
</dd><dt><a href="BigDecimal.html#ROUND_CEILING"><code>ROUND_CEILING</code></a>, :ceiling, :ceil
<dd>
<p>round towards positive infinity (ceil)</p>
</dd><dt><a href="BigDecimal.html#ROUND_FLOOR"><code>ROUND_FLOOR</code></a>, :floor
<dd>
<p>round towards negative infinity (floor)</p>
</dd></dl>
            

            
            <div class="method-source-code" id="mode-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
BigDecimal_mode(int argc, VALUE *argv, VALUE self)
{
    VALUE which;
    VALUE val;
    unsigned long f,fo;

    rb_scan_args(argc, argv, &quot;11&quot;, &amp;which, &amp;val);
    f = (unsigned long)NUM2INT(which);

    if (f &amp; VP_EXCEPTION_ALL) {
        /* Exception mode setting */
        fo = VpGetException();
        if (val == Qnil) return INT2FIX(fo);
        if (val != Qfalse &amp;&amp; val!=Qtrue) {
            rb_raise(rb_eArgError, &quot;second argument must be true or false&quot;);
            return Qnil; /* Not reached */
        }
        if (f &amp; VP_EXCEPTION_INFINITY) {
            VpSetException((unsigned short)((val == Qtrue) ? (fo | VP_EXCEPTION_INFINITY) :
                        (fo &amp; (~VP_EXCEPTION_INFINITY))));
        }
        fo = VpGetException();
        if (f &amp; VP_EXCEPTION_NaN) {
            VpSetException((unsigned short)((val == Qtrue) ? (fo | VP_EXCEPTION_NaN) :
                        (fo &amp; (~VP_EXCEPTION_NaN))));
        }
        fo = VpGetException();
        if (f &amp; VP_EXCEPTION_UNDERFLOW) {
            VpSetException((unsigned short)((val == Qtrue) ? (fo | VP_EXCEPTION_UNDERFLOW) :
                        (fo &amp; (~VP_EXCEPTION_UNDERFLOW))));
        }
        fo = VpGetException();
        if(f &amp; VP_EXCEPTION_ZERODIVIDE) {
            VpSetException((unsigned short)((val == Qtrue) ? (fo | VP_EXCEPTION_ZERODIVIDE) :
                        (fo &amp; (~VP_EXCEPTION_ZERODIVIDE))));
        }
        fo = VpGetException();
        return INT2FIX(fo);
    }
    if (VP_ROUND_MODE == f) {
        /* Rounding mode setting */
        unsigned short sw;
        fo = VpGetRoundMode();
        if (NIL_P(val)) return INT2FIX(fo);
        sw = check_rounding_mode(val);
        fo = VpSetRoundMode(sw);
        return INT2FIX(fo);
    }
    rb_raise(rb_eTypeError, &quot;first argument for BigDecimal.mode invalid&quot;);
    return Qnil;
}
            </pre> 
            </div><!-- mode-source -->
            
          </div>

          

          
        </div><!-- mode-method -->
      
        <div id="save_exception_mode-method" class="method-detail ">
          <a name="method-c-save_exception_mode"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">save_exception_mode { ... }</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Execute the provided block, but preserve the exception mode</p>

<pre class="ruby"><span class="ruby-constant">BigDecimal</span>.<span class="ruby-identifier">save_exception_mode</span> <span class="ruby-keyword">do</span>
  <span class="ruby-constant">BigDecimal</span>.<span class="ruby-identifier">mode</span>(<span class="ruby-constant">BigDecimal</span><span class="ruby-operator">::</span><span class="ruby-constant">EXCEPTION_OVERFLOW</span>, <span class="ruby-keyword">false</span>)
  <span class="ruby-constant">BigDecimal</span>.<span class="ruby-identifier">mode</span>(<span class="ruby-constant">BigDecimal</span><span class="ruby-operator">::</span><span class="ruby-constant">EXCEPTION_NaN</span>, <span class="ruby-keyword">false</span>)

  <span class="ruby-constant">BigDecimal</span>(<span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&#39;Infinity&#39;</span>))
  <span class="ruby-constant">BigDecimal</span>(<span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&#39;-Infinity&#39;</span>))
  <span class="ruby-constant">BigDecimal</span>(<span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&#39;NaN&#39;</span>))
<span class="ruby-keyword">end</span>
</pre>

<p>For use with the BigDecimal::EXCEPTION_*</p>

<p>See <a href="BigDecimal.html#method-c-mode"><code>BigDecimal.mode</code></a></p>
            

            
            <div class="method-source-code" id="save_exception_mode-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
BigDecimal_save_exception_mode(VALUE self)
{
    unsigned short const exception_mode = VpGetException();
    int state;
    VALUE ret = rb_protect(rb_yield, Qnil, &amp;state);
    VpSetException(exception_mode);
    if (state) rb_jump_tag(state);
    return ret;
}
            </pre> 
            </div><!-- save_exception_mode-source -->
            
          </div>

          

          
        </div><!-- save_exception_mode-method -->
      
        <div id="save_limit-method" class="method-detail ">
          <a name="method-c-save_limit"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">save_limit { ... }</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Execute the provided block, but preserve the precision limit</p>

<pre class="ruby"><span class="ruby-constant">BigDecimal</span>.<span class="ruby-identifier">limit</span>(<span class="ruby-value">100</span>)
<span class="ruby-identifier">puts</span> <span class="ruby-constant">BigDecimal</span>.<span class="ruby-identifier">limit</span>
<span class="ruby-constant">BigDecimal</span>.<span class="ruby-identifier">save_limit</span> <span class="ruby-keyword">do</span>
    <span class="ruby-constant">BigDecimal</span>.<span class="ruby-identifier">limit</span>(<span class="ruby-value">200</span>)
    <span class="ruby-identifier">puts</span> <span class="ruby-constant">BigDecimal</span>.<span class="ruby-identifier">limit</span>
<span class="ruby-keyword">end</span>
<span class="ruby-identifier">puts</span> <span class="ruby-constant">BigDecimal</span>.<span class="ruby-identifier">limit</span>
</pre>
            

            
            <div class="method-source-code" id="save_limit-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
BigDecimal_save_limit(VALUE self)
{
    size_t const limit = VpGetPrecLimit();
    int state;
    VALUE ret = rb_protect(rb_yield, Qnil, &amp;state);
    VpSetPrecLimit(limit);
    if (state) rb_jump_tag(state);
    return ret;
}
            </pre> 
            </div><!-- save_limit-source -->
            
          </div>

          

          
        </div><!-- save_limit-method -->
      
        <div id="save_rounding_mode-method" class="method-detail ">
          <a name="method-c-save_rounding_mode"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">save_rounding_mode { ... }</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Execute the provided block, but preserve the rounding mode</p>

<pre class="ruby"><span class="ruby-constant">BigDecimal</span>.<span class="ruby-identifier">save_rounding_mode</span> <span class="ruby-keyword">do</span>
  <span class="ruby-constant">BigDecimal</span>.<span class="ruby-identifier">mode</span>(<span class="ruby-constant">BigDecimal</span><span class="ruby-operator">::</span><span class="ruby-constant">ROUND_MODE</span>, <span class="ruby-value">:up</span>)
  <span class="ruby-identifier">puts</span> <span class="ruby-constant">BigDecimal</span>.<span class="ruby-identifier">mode</span>(<span class="ruby-constant">BigDecimal</span><span class="ruby-operator">::</span><span class="ruby-constant">ROUND_MODE</span>)
<span class="ruby-keyword">end</span>
</pre>

<p>For use with the BigDecimal::ROUND_*</p>

<p>See <a href="BigDecimal.html#method-c-mode"><code>BigDecimal.mode</code></a></p>
            

            
            <div class="method-source-code" id="save_rounding_mode-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
BigDecimal_save_rounding_mode(VALUE self)
{
    unsigned short const round_mode = VpGetRoundMode();
    int state;
    VALUE ret = rb_protect(rb_yield, Qnil, &amp;state);
    VpSetRoundMode(round_mode);
    if (state) rb_jump_tag(state);
    return ret;
}
            </pre> 
            </div><!-- save_rounding_mode-source -->
            
          </div>

          

          
        </div><!-- save_rounding_mode-method -->
      
      </div><!-- public-class-method-details -->
    
      <div id="public-instance-method-details" class="method-section section">
        <h3 class="section-header">Public Instance Methods</h3>

      
        <div id="25-method" class="method-detail ">
          <a name="method-i-25"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">a % b</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the modulus from dividing by b.</p>

<p>See <a href="BigDecimal.html#method-i-divmod"><code>BigDecimal#divmod</code></a>.</p>
            

            
            <div class="method-source-code" id="25-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
BigDecimal_mod(VALUE self, VALUE r) 
            </pre> 
            </div><!-- 25-source -->
            
          </div>

          

          
        </div><!-- 25-method -->
      
        <div id="2A-method" class="method-detail ">
          <a name="method-i-2A"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">mult(value, digits)</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Multiply by the specified value.</p>

<p>e.g.</p>

<pre class="ruby"><span class="ruby-identifier">c</span> = <span class="ruby-identifier">a</span>.<span class="ruby-identifier">mult</span>(<span class="ruby-identifier">b</span>,<span class="ruby-identifier">n</span>)
<span class="ruby-identifier">c</span> = <span class="ruby-identifier">a</span> <span class="ruby-operator">*</span> <span class="ruby-identifier">b</span>
</pre>
<dl class="rdoc-list note-list"><dt>digits
<dd>
<p>If specified and less than the number of significant digits of the result, the result is rounded to that number of digits, according to <a href="BigDecimal.html#method-c-mode"><code>BigDecimal.mode</code></a>.</p>
</dd></dl>
            

            
            <div class="method-source-code" id="2A-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
BigDecimal_mult(VALUE self, VALUE r)
{
    ENTER(5);
    Real *c, *a, *b;
    size_t mx;

    GUARD_OBJ(a, GetVpValue(self, 1));
    if (RB_TYPE_P(r, T_FLOAT)) {
        b = GetVpValueWithPrec(r, DBL_DIG+1, 1);
    }
    else if (RB_TYPE_P(r, T_RATIONAL)) {
        b = GetVpValueWithPrec(r, a-&gt;Prec*VpBaseFig(), 1);
    }
    else {
        b = GetVpValue(r,0);
    }

    if (!b) return DoSomeOne(self, r, &#39;*&#39;);
    SAVE(b);

    mx = a-&gt;Prec + b-&gt;Prec;
    GUARD_OBJ(c, VpCreateRbObject(mx *(VpBaseFig() + 1), &quot;0&quot;));
    VpMult(c, a, b);
    return ToValue(c);
}
            </pre> 
            </div><!-- 2A-source -->
            
          </div>

          

          
        </div><!-- 2A-method -->
      
        <div id="2A-2A-method" class="method-detail ">
          <a name="method-i-2A-2A"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">a ** n  &rarr; bigdecimal</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the value raised to the power of n.</p>

<p>See <a href="BigDecimal.html#method-i-power"><code>BigDecimal#power</code></a>.</p>
            

            
            <div class="method-source-code" id="2A-2A-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
BigDecimal_power_op(VALUE self, VALUE exp)
{
    return BigDecimal_power(1, &amp;exp, self);
}
            </pre> 
            </div><!-- 2A-2A-source -->
            
          </div>

          

          
        </div><!-- 2A-2A-method -->
      
        <div id="2B-method" class="method-detail ">
          <a name="method-i-2B"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">add(value, digits)</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Add the specified value.</p>

<p>e.g.</p>

<pre class="ruby"><span class="ruby-identifier">c</span> = <span class="ruby-identifier">a</span>.<span class="ruby-identifier">add</span>(<span class="ruby-identifier">b</span>,<span class="ruby-identifier">n</span>)
<span class="ruby-identifier">c</span> = <span class="ruby-identifier">a</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">b</span>
</pre>
<dl class="rdoc-list note-list"><dt>digits
<dd>
<p>If specified and less than the number of significant digits of the result, the result is rounded to that number of digits, according to <a href="BigDecimal.html#method-c-mode"><code>BigDecimal.mode</code></a>.</p>
</dd></dl>
            

            
            <div class="method-source-code" id="2B-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
BigDecimal_add(VALUE self, VALUE r)
{
    ENTER(5);
    Real *c, *a, *b;
    size_t mx;

    GUARD_OBJ(a, GetVpValue(self, 1));
    if (RB_TYPE_P(r, T_FLOAT)) {
        b = GetVpValueWithPrec(r, DBL_DIG+1, 1);
    }
    else if (RB_TYPE_P(r, T_RATIONAL)) {
        b = GetVpValueWithPrec(r, a-&gt;Prec*VpBaseFig(), 1);
    }
    else {
        b = GetVpValue(r, 0);
    }

    if (!b) return DoSomeOne(self,r,&#39;+&#39;);
    SAVE(b);

    if (VpIsNaN(b)) return b-&gt;obj;
    if (VpIsNaN(a)) return a-&gt;obj;

    mx = GetAddSubPrec(a, b);
    if (mx == (size_t)-1L) {
        GUARD_OBJ(c,VpCreateRbObject(VpBaseFig() + 1, &quot;0&quot;));
        VpAddSub(c, a, b, 1);
    }
    else {
        GUARD_OBJ(c, VpCreateRbObject(mx * (VpBaseFig() + 1), &quot;0&quot;));
        if(!mx) {
            VpSetInf(c, VpGetSign(a));
        }
        else {
            VpAddSub(c, a, b, 1);
        }
    }
    return ToValue(c);
}
            </pre> 
            </div><!-- 2B-source -->
            
          </div>

          

          
        </div><!-- 2B-method -->
      
        <div id="2B-40-method" class="method-detail ">
          <a name="method-i-2B-40"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">+big_decimal  &rarr;  big_decimal</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Return self.</p>

<pre class="ruby"><span class="ruby-operator">+</span><span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&#39;5&#39;</span>)  <span class="ruby-comment">#=&gt; 0.5e1</span>
</pre>
            

            
            <div class="method-source-code" id="2B-40-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
BigDecimal_uplus(VALUE self)
{
    return self;
}
            </pre> 
            </div><!-- 2B-40-source -->
            
          </div>

          

          
        </div><!-- 2B-40-method -->
      
        <div id="2D-method" class="method-detail ">
          <a name="method-i-2D"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">a - b   &rarr; bigdecimal</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Subtract the specified value.</p>

<p>e.g.</p>

<pre class="ruby"><span class="ruby-identifier">c</span> = <span class="ruby-identifier">a</span> <span class="ruby-operator">-</span> <span class="ruby-identifier">b</span>
</pre>

<p>The precision of the result value depends on the type of <code>b</code>.</p>

<p>If <code>b</code> is a <a href="Float.html"><code>Float</code></a>, the precision of the result is Float::DIG+1.</p>

<p>If <code>b</code> is a <a href="BigDecimal.html"><code>BigDecimal</code></a>, the precision of the result is <code>b</code>&#39;s precision of internal representation from platform. So, it&#39;s return value is platform dependent.</p>
            

            
            <div class="method-source-code" id="2D-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
BigDecimal_sub(VALUE self, VALUE r)
{
    ENTER(5);
    Real *c, *a, *b;
    size_t mx;

    GUARD_OBJ(a, GetVpValue(self,1));
    if (RB_TYPE_P(r, T_FLOAT)) {
        b = GetVpValueWithPrec(r, DBL_DIG+1, 1);
    }
    else if (RB_TYPE_P(r, T_RATIONAL)) {
        b = GetVpValueWithPrec(r, a-&gt;Prec*VpBaseFig(), 1);
    }
    else {
        b = GetVpValue(r,0);
    }

    if (!b) return DoSomeOne(self,r,&#39;-&#39;);
    SAVE(b);

    if (VpIsNaN(b)) return b-&gt;obj;
    if (VpIsNaN(a)) return a-&gt;obj;

    mx = GetAddSubPrec(a,b);
    if (mx == (size_t)-1L) {
        GUARD_OBJ(c,VpCreateRbObject(VpBaseFig() + 1, &quot;0&quot;));
        VpAddSub(c, a, b, -1);
    }
    else {
        GUARD_OBJ(c,VpCreateRbObject(mx *(VpBaseFig() + 1), &quot;0&quot;));
        if (!mx) {
            VpSetInf(c,VpGetSign(a));
        }
        else {
            VpAddSub(c, a, b, -1);
        }
    }
    return ToValue(c);
}
            </pre> 
            </div><!-- 2D-source -->
            
          </div>

          

          
        </div><!-- 2D-method -->
      
        <div id="2D-40-method" class="method-detail ">
          <a name="method-i-2D-40"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">-big_decimal  &rarr;  big_decimal</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Return the negation of self.</p>

<pre class="ruby"><span class="ruby-operator">-</span><span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&#39;5&#39;</span>)  <span class="ruby-comment">#=&gt; -0.5e1</span>
</pre>
            

            
            <div class="method-source-code" id="2D-40-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
BigDecimal_neg(VALUE self)
{
    ENTER(5);
    Real *c, *a;
    GUARD_OBJ(a, GetVpValue(self, 1));
    GUARD_OBJ(c, VpCreateRbObject(a-&gt;Prec *(VpBaseFig() + 1), &quot;0&quot;));
    VpAsgn(c, a, -1);
    return ToValue(c);
}
            </pre> 
            </div><!-- 2D-40-source -->
            
          </div>

          

          
        </div><!-- 2D-40-method -->
      
        <div id="2F-method" class="method-detail ">
          <a name="method-i-2F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">a / b       &rarr; bigdecimal</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Divide by the specified value.</p>

<p>See <a href="BigDecimal.html#method-i-div"><code>BigDecimal#div</code></a>.</p>
            

            
            <div class="method-source-code" id="2F-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
BigDecimal_div(VALUE self, VALUE r)
/* For c = self/r: with round operation */
{
    ENTER(5);
    Real *c=NULL, *res=NULL, *div = NULL;
    r = BigDecimal_divide(&amp;c, &amp;res, &amp;div, self, r);
    if (!NIL_P(r)) return r; /* coerced by other */
    SAVE(c); SAVE(res); SAVE(div);
    /* a/b = c + r/b */
    /* c xxxxx
       r 00000yyyyy  ==&gt; (y/b)*BASE &gt;= HALF_BASE
     */
    /* Round */
    if (VpHasVal(div)) { /* frac[0] must be zero for NaN,INF,Zero */
        VpInternalRound(c, 0, c-&gt;frac[c-&gt;Prec-1], (BDIGIT)(VpBaseVal() * (BDIGIT_DBL)res-&gt;frac[0] / div-&gt;frac[0]));
    }
    return ToValue(c);
}
            </pre> 
            </div><!-- 2F-source -->
            
          </div>

          

          
        </div><!-- 2F-method -->
      
        <div id="3C-method" class="method-detail ">
          <a name="method-i-3C"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">a < b</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns true if a is less than b.</p>

<p>Values may be coerced to perform the comparison (see ==, <a href="BigDecimal.html#method-i-coerce"><code>BigDecimal#coerce</code></a>).</p>
            

            
            <div class="method-source-code" id="3C-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
BigDecimal_lt(VALUE self, VALUE r)
{
    return BigDecimalCmp(self, r, &#39;&lt;&#39;);
}
            </pre> 
            </div><!-- 3C-source -->
            
          </div>

          

          
        </div><!-- 3C-method -->
      
        <div id="3C-3D-method" class="method-detail ">
          <a name="method-i-3C-3D"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">a <= b</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns true if a is less than or equal to b.</p>

<p>Values may be coerced to perform the comparison (see ==, <a href="BigDecimal.html#method-i-coerce"><code>BigDecimal#coerce</code></a>).</p>
            

            
            <div class="method-source-code" id="3C-3D-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
BigDecimal_le(VALUE self, VALUE r)
{
    return BigDecimalCmp(self, r, &#39;L&#39;);
}
            </pre> 
            </div><!-- 3C-3D-source -->
            
          </div>

          

          
        </div><!-- 3C-3D-method -->
      
        <div id="3C-3D-3E-method" class="method-detail ">
          <a name="method-i-3C-3D-3E"></a>

          
          <div class="method-heading">
            <span class="method-name">&lt;=&gt;</span><span
              class="method-args">(p1)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          
          <div>
  
            
            <p>The comparison operator. a &lt;=&gt; b is 0 if a == b, 1 if a &gt; b, -1 if a &lt; b.</p>
            

            
            <div class="method-source-code" id="3C-3D-3E-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
BigDecimal_comp(VALUE self, VALUE r)
{
    return BigDecimalCmp(self, r, &#39;*&#39;);
}
            </pre> 
            </div><!-- 3C-3D-3E-source -->
            
          </div>

          

          
        </div><!-- 3C-3D-3E-method -->
      
        <div id="3D-3D-method" class="method-detail ">
          <a name="method-i-3D-3D"></a>

          
          <div class="method-heading">
            <span class="method-name">==</span><span
              class="method-args">(p1)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          
          <div>
  
            
            <p>Tests for value equality; returns true if the values are equal.</p>

<p>The == and === operators and the eql? method have the same implementation for <a href="BigDecimal.html"><code>BigDecimal</code></a>.</p>

<p>Values may be coerced to perform the comparison:</p>

<pre class="ruby"><span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&#39;1.0&#39;</span>) <span class="ruby-operator">==</span> <span class="ruby-value">1.0</span>  <span class="ruby-comment">#=&gt; true</span>
</pre>
            

            
            <div class="method-source-code" id="3D-3D-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
BigDecimal_eq(VALUE self, VALUE r)
{
    return BigDecimalCmp(self, r, &#39;=&#39;);
}
            </pre> 
            </div><!-- 3D-3D-source -->
            
          </div>

          

          
        </div><!-- 3D-3D-method -->
      
        <div id="3D-3D-3D-method" class="method-detail ">
          <a name="method-i-3D-3D-3D"></a>

          
          <div class="method-heading">
            <span class="method-name">===</span><span
              class="method-args">(p1)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          
          <div>
  
            
            <p>Tests for value equality; returns true if the values are equal.</p>

<p>The == and === operators and the eql? method have the same implementation for <a href="BigDecimal.html"><code>BigDecimal</code></a>.</p>

<p>Values may be coerced to perform the comparison:</p>

<pre class="ruby"><span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&#39;1.0&#39;</span>) <span class="ruby-operator">==</span> <span class="ruby-value">1.0</span>  <span class="ruby-comment">#=&gt; true</span>
</pre>
            

            
            <div class="method-source-code" id="3D-3D-3D-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
BigDecimal_eq(VALUE self, VALUE r)
{
    return BigDecimalCmp(self, r, &#39;=&#39;);
}
            </pre> 
            </div><!-- 3D-3D-3D-source -->
            
          </div>

          

          
        </div><!-- 3D-3D-3D-method -->
      
        <div id="3E-method" class="method-detail ">
          <a name="method-i-3E"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">a > b</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns true if a is greater than b.</p>

<p>Values may be coerced to perform the comparison (see ==, <a href="BigDecimal.html#method-i-coerce"><code>BigDecimal#coerce</code></a>).</p>
            

            
            <div class="method-source-code" id="3E-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
BigDecimal_gt(VALUE self, VALUE r)
{
    return BigDecimalCmp(self, r, &#39;&gt;&#39;);
}
            </pre> 
            </div><!-- 3E-source -->
            
          </div>

          

          
        </div><!-- 3E-method -->
      
        <div id="3E-3D-method" class="method-detail ">
          <a name="method-i-3E-3D"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">a >= b</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns true if a is greater than or equal to b.</p>

<p>Values may be coerced to perform the comparison (see ==, <a href="BigDecimal.html#method-i-coerce"><code>BigDecimal#coerce</code></a>)</p>
            

            
            <div class="method-source-code" id="3E-3D-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
BigDecimal_ge(VALUE self, VALUE r)
{
    return BigDecimalCmp(self, r, &#39;G&#39;);
}
            </pre> 
            </div><!-- 3E-3D-source -->
            
          </div>

          

          
        </div><!-- 3E-3D-method -->
      
        <div id="_dump-method" class="method-detail ">
          <a name="method-i-_dump"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">_dump</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Method used to provide marshalling support.</p>

<pre class="ruby"><span class="ruby-identifier">inf</span> = <span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&#39;Infinity&#39;</span>)
  <span class="ruby-comment">#=&gt; Infinity</span>
<span class="ruby-constant">BigDecimal</span>.<span class="ruby-identifier">_load</span>(<span class="ruby-identifier">inf</span>.<span class="ruby-identifier">_dump</span>)
  <span class="ruby-comment">#=&gt; Infinity</span>
</pre>

<p>See the Marshal module.</p>
            

            
            <div class="method-source-code" id="_dump-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
BigDecimal_dump(int argc, VALUE *argv, VALUE self)
{
    ENTER(5);
    Real *vp;
    char *psz;
    VALUE dummy;
    volatile VALUE dump;

    rb_scan_args(argc, argv, &quot;01&quot;, &amp;dummy);
    GUARD_OBJ(vp,GetVpValue(self, 1));
    dump = rb_str_new(0, VpNumOfChars(vp, &quot;E&quot;)+50);
    psz = RSTRING_PTR(dump);
    sprintf(psz, &quot;%&quot;PRIuSIZE&quot;:&quot;, VpMaxPrec(vp)*VpBaseFig());
    VpToString(vp, psz+strlen(psz), 0, 0);
    rb_str_resize(dump, strlen(psz));
    return dump;
}
            </pre> 
            </div><!-- _dump-source -->
            
          </div>

          

          
        </div><!-- _dump-method -->
      
        <div id="abs-method" class="method-detail ">
          <a name="method-i-abs"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">abs  &rarr;  big_decimal</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the absolute value, as a <a href="BigDecimal.html"><code>BigDecimal</code></a>.</p>

<pre class="ruby"><span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&#39;5&#39;</span>).<span class="ruby-identifier">abs</span>  <span class="ruby-comment">#=&gt; 0.5e1</span>
<span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&#39;-3&#39;</span>).<span class="ruby-identifier">abs</span> <span class="ruby-comment">#=&gt; 0.3e1</span>
</pre>
            

            
            <div class="method-source-code" id="abs-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
BigDecimal_abs(VALUE self)
{
    ENTER(5);
    Real *c, *a;
    size_t mx;

    GUARD_OBJ(a, GetVpValue(self, 1));
    mx = a-&gt;Prec *(VpBaseFig() + 1);
    GUARD_OBJ(c, VpCreateRbObject(mx, &quot;0&quot;));
    VpAsgn(c, a, 1);
    VpChangeSign(c, 1);
    return ToValue(c);
}
            </pre> 
            </div><!-- abs-source -->
            
          </div>

          

          
        </div><!-- abs-method -->
      
        <div id="add-method" class="method-detail ">
          <a name="method-i-add"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">add(value, digits)</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Add the specified value.</p>

<p>e.g.</p>

<pre class="ruby"><span class="ruby-identifier">c</span> = <span class="ruby-identifier">a</span>.<span class="ruby-identifier">add</span>(<span class="ruby-identifier">b</span>,<span class="ruby-identifier">n</span>)
<span class="ruby-identifier">c</span> = <span class="ruby-identifier">a</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">b</span>
</pre>
<dl class="rdoc-list note-list"><dt>digits
<dd>
<p>If specified and less than the number of significant digits of the result, the result is rounded to that number of digits, according to <a href="BigDecimal.html#method-c-mode"><code>BigDecimal.mode</code></a>.</p>
</dd></dl>
            

            
            <div class="method-source-code" id="add-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
BigDecimal_add2(VALUE self, VALUE b, VALUE n)
{
    ENTER(2);
    Real *cv;
    SIGNED_VALUE mx = GetPrecisionInt(n);
    if (mx == 0) return BigDecimal_add(self, b);
    else {
        size_t pl = VpSetPrecLimit(0);
        VALUE   c = BigDecimal_add(self, b);
        VpSetPrecLimit(pl);
        GUARD_OBJ(cv, GetVpValue(c, 1));
        VpLeftRound(cv, VpGetRoundMode(), mx);
        return ToValue(cv);
    }
}
            </pre> 
            </div><!-- add-source -->
            
          </div>

          

          
        </div><!-- add-method -->
      
        <div id="ceil-method" class="method-detail ">
          <a name="method-i-ceil"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">ceil(n)</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Return the smallest integer greater than or equal to the value, as a <a href="BigDecimal.html"><code>BigDecimal</code></a>.</p>

<pre class="ruby"><span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&#39;3.14159&#39;</span>).<span class="ruby-identifier">ceil</span> <span class="ruby-comment">#=&gt; 4</span>
<span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&#39;-9.1&#39;</span>).<span class="ruby-identifier">ceil</span> <span class="ruby-comment">#=&gt; -9</span>
</pre>

<p>If n is specified and positive, the fractional part of the result has no more than that many digits.</p>

<p>If n is specified and negative, at least that many digits to the left of the decimal point will be 0 in the result.</p>

<pre class="ruby"><span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&#39;3.14159&#39;</span>).<span class="ruby-identifier">ceil</span>(<span class="ruby-value">3</span>) <span class="ruby-comment">#=&gt; 3.142</span>
<span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&#39;13345.234&#39;</span>).<span class="ruby-identifier">ceil</span>(<span class="ruby-value">-2</span>) <span class="ruby-comment">#=&gt; 13400.0</span>
</pre>
            

            
            <div class="method-source-code" id="ceil-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
BigDecimal_ceil(int argc, VALUE *argv, VALUE self)
{
    ENTER(5);
    Real *c, *a;
    int iLoc;
    VALUE vLoc;
    size_t mx, pl = VpSetPrecLimit(0);

    if (rb_scan_args(argc, argv, &quot;01&quot;, &amp;vLoc) == 0) {
        iLoc = 0;
    } else {
        iLoc = NUM2INT(vLoc);
    }

    GUARD_OBJ(a, GetVpValue(self, 1));
    mx = a-&gt;Prec * (VpBaseFig() + 1);
    GUARD_OBJ(c, VpCreateRbObject(mx, &quot;0&quot;));
    VpSetPrecLimit(pl);
    VpActiveRound(c, a, VP_ROUND_CEIL, iLoc);
    if (argc == 0) {
        return BigDecimal_to_i(ToValue(c));
    }
    return ToValue(c);
}
            </pre> 
            </div><!-- ceil-source -->
            
          </div>

          

          
        </div><!-- ceil-method -->
      
        <div id="clone-method" class="method-detail ">
          <a name="method-i-clone"></a>

          
          <div class="method-heading">
            <span class="method-name">clone</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          
          <div>
  
            
            
            

            
            <div class="method-source-code" id="clone-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
BigDecimal_clone(VALUE self)
{
  return self;
}
            </pre> 
            </div><!-- clone-source -->
            
          </div>

          

          
        </div><!-- clone-method -->
      
        <div id="coerce-method" class="method-detail ">
          <a name="method-i-coerce"></a>

          
          <div class="method-heading">
            <span class="method-name">coerce</span><span
              class="method-args">(p1)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          
          <div>
  
            
            <p>The coerce method provides support for Ruby type coercion. It is not enabled by default.</p>

<p>This means that binary operations like + * / or - can often be performed on a <a href="BigDecimal.html"><code>BigDecimal</code></a> and an object of another type, if the other object can be coerced into a <a href="BigDecimal.html"><code>BigDecimal</code></a> value.</p>

<p>e.g.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&quot;1.0&quot;</span>)
<span class="ruby-identifier">b</span> = <span class="ruby-identifier">a</span> <span class="ruby-operator">/</span> <span class="ruby-value">2.0</span> <span class="ruby-comment">#=&gt; 0.5</span>
</pre>

<p>Note that coercing a <a href="String.html"><code>String</code></a> to a <a href="BigDecimal.html"><code>BigDecimal</code></a> is not supported by default; it requires a special compile-time option when building Ruby.</p>
            

            
            <div class="method-source-code" id="coerce-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
BigDecimal_coerce(VALUE self, VALUE other)
{
    ENTER(2);
    VALUE obj;
    Real *b;

    if (RB_TYPE_P(other, T_FLOAT)) {
        GUARD_OBJ(b, GetVpValueWithPrec(other, DBL_DIG+1, 1));
        obj = rb_assoc_new(ToValue(b), self);
    }
    else {
        if (RB_TYPE_P(other, T_RATIONAL)) {
            Real* pv = DATA_PTR(self);
            GUARD_OBJ(b, GetVpValueWithPrec(other, pv-&gt;Prec*VpBaseFig(), 1));
        }
        else {
            GUARD_OBJ(b, GetVpValue(other, 1));
        }
        obj = rb_assoc_new(b-&gt;obj, self);
    }

    return obj;
}
            </pre> 
            </div><!-- coerce-source -->
            
          </div>

          

          
        </div><!-- coerce-method -->
      
        <div id="div-method" class="method-detail ">
          <a name="method-i-div"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">div(value, digits)  &rarr; bigdecimal or integer</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Divide by the specified value.</p>
<dl class="rdoc-list note-list"><dt>digits
<dd>
<p>If specified and less than the number of significant digits of the result, the result is rounded to that number of digits, according to <a href="BigDecimal.html#method-c-mode"><code>BigDecimal.mode</code></a>.</p>

<p>If digits is 0, the result is the same as for the / operator or <a href="BigDecimal.html#method-i-quo"><code>quo</code></a>.</p>

<p>If digits is not specified, the result is an integer, by analogy with Float#div; see also <a href="BigDecimal.html#method-i-divmod"><code>BigDecimal#divmod</code></a>.</p>
</dd></dl>

<p>Examples:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&quot;4&quot;</span>)
<span class="ruby-identifier">b</span> = <span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&quot;3&quot;</span>)

<span class="ruby-identifier">a</span>.<span class="ruby-identifier">div</span>(<span class="ruby-identifier">b</span>, <span class="ruby-value">3</span>)  <span class="ruby-comment"># =&gt; 0.133e1</span>

<span class="ruby-identifier">a</span>.<span class="ruby-identifier">div</span>(<span class="ruby-identifier">b</span>, <span class="ruby-value">0</span>)  <span class="ruby-comment"># =&gt; 0.1333333333333333333e1</span>
<span class="ruby-identifier">a</span> <span class="ruby-operator">/</span> <span class="ruby-identifier">b</span>        <span class="ruby-comment"># =&gt; 0.1333333333333333333e1</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">quo</span>(<span class="ruby-identifier">b</span>)     <span class="ruby-comment"># =&gt; 0.1333333333333333333e1</span>

<span class="ruby-identifier">a</span>.<span class="ruby-identifier">div</span>(<span class="ruby-identifier">b</span>)     <span class="ruby-comment"># =&gt; 1</span>
</pre>
            

            
            <div class="method-source-code" id="div-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
BigDecimal_div3(int argc, VALUE *argv, VALUE self)
{
    VALUE b,n;

    rb_scan_args(argc, argv, &quot;11&quot;, &amp;b, &amp;n);

    return BigDecimal_div2(self, b, n);
}
            </pre> 
            </div><!-- div-source -->
            
          </div>

          

          
        </div><!-- div-method -->
      
        <div id="divmod-method" class="method-detail ">
          <a name="method-i-divmod"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">divmod(value)</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Divides by the specified value, and returns the quotient and modulus as <a href="BigDecimal.html"><code>BigDecimal</code></a> numbers. The quotient is rounded towards negative infinity.</p>

<p>For example:</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&#39;bigdecimal&#39;</span>

<span class="ruby-identifier">a</span> = <span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&quot;42&quot;</span>)
<span class="ruby-identifier">b</span> = <span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&quot;9&quot;</span>)

<span class="ruby-identifier">q</span>, <span class="ruby-identifier">m</span> = <span class="ruby-identifier">a</span>.<span class="ruby-identifier">divmod</span>(<span class="ruby-identifier">b</span>)

<span class="ruby-identifier">c</span> = <span class="ruby-identifier">q</span> <span class="ruby-operator">*</span> <span class="ruby-identifier">b</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">m</span>

<span class="ruby-identifier">a</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">c</span>  <span class="ruby-comment">#=&gt; true</span>
</pre>

<p>The quotient q is (a/b).floor, and the modulus is the amount that must be added to q * b to get a.</p>
            

            
            <div class="method-source-code" id="divmod-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
BigDecimal_divmod(VALUE self, VALUE r)
{
    ENTER(5);
    Real *div = NULL, *mod = NULL;

    if (BigDecimal_DoDivmod(self, r, &amp;div, &amp;mod)) {
        SAVE(div); SAVE(mod);
        return rb_assoc_new(ToValue(div), ToValue(mod));
    }
    return DoSomeOne(self,r,rb_intern(&quot;divmod&quot;));
}
            </pre> 
            </div><!-- divmod-source -->
            
          </div>

          

          
        </div><!-- divmod-method -->
      
        <div id="dup-method" class="method-detail ">
          <a name="method-i-dup"></a>

          
          <div class="method-heading">
            <span class="method-name">dup</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          
          <div>
  
            
            
            

            
            <div class="method-source-code" id="dup-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
BigDecimal_clone(VALUE self)
{
  return self;
}
            </pre> 
            </div><!-- dup-source -->
            
          </div>

          

          
        </div><!-- dup-method -->
      
        <div id="eql-3F-method" class="method-detail ">
          <a name="method-i-eql-3F"></a>

          
          <div class="method-heading">
            <span class="method-name">eql?</span><span
              class="method-args">(p1)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          
          <div>
  
            
            <p>Tests for value equality; returns true if the values are equal.</p>

<p>The == and === operators and the eql? method have the same implementation for <a href="BigDecimal.html"><code>BigDecimal</code></a>.</p>

<p>Values may be coerced to perform the comparison:</p>

<pre class="ruby"><span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&#39;1.0&#39;</span>) <span class="ruby-operator">==</span> <span class="ruby-value">1.0</span>  <span class="ruby-comment">#=&gt; true</span>
</pre>
            

            
            <div class="method-source-code" id="eql-3F-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
BigDecimal_eq(VALUE self, VALUE r)
{
    return BigDecimalCmp(self, r, &#39;=&#39;);
}
            </pre> 
            </div><!-- eql-3F-source -->
            
          </div>

          

          
        </div><!-- eql-3F-method -->
      
        <div id="exponent-method" class="method-detail ">
          <a name="method-i-exponent"></a>

          
          <div class="method-heading">
            <span class="method-name">exponent</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          
          <div>
  
            
            <p>Returns the exponent of the <a href="BigDecimal.html"><code>BigDecimal</code></a> number, as an <a href="Integer.html"><code>Integer</code></a>.</p>

<p>If the number can be represented as 0.xxxxxx*10**n where xxxxxx is a string of digits with no leading zeros, then n is the exponent.</p>
            

            
            <div class="method-source-code" id="exponent-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
BigDecimal_exponent(VALUE self)
{
    ssize_t e = VpExponent10(GetVpValue(self, 1));
    return INT2NUM(e);
}
            </pre> 
            </div><!-- exponent-source -->
            
          </div>

          

          
        </div><!-- exponent-method -->
      
        <div id="finite-3F-method" class="method-detail ">
          <a name="method-i-finite-3F"></a>

          
          <div class="method-heading">
            <span class="method-name">finite?</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          
          <div>
  
            
            <p>Returns True if the value is finite (not NaN or infinite).</p>
            

            
            <div class="method-source-code" id="finite-3F-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
BigDecimal_IsFinite(VALUE self)
{
    Real *p = GetVpValue(self, 1);
    if (VpIsNaN(p)) return Qfalse;
    if (VpIsInf(p)) return Qfalse;
    return Qtrue;
}
            </pre> 
            </div><!-- finite-3F-source -->
            
          </div>

          

          
        </div><!-- finite-3F-method -->
      
        <div id="fix-method" class="method-detail ">
          <a name="method-i-fix"></a>

          
          <div class="method-heading">
            <span class="method-name">fix</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          
          <div>
  
            
            <p>Return the integer part of the number, as a <a href="BigDecimal.html"><code>BigDecimal</code></a>.</p>
            

            
            <div class="method-source-code" id="fix-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
BigDecimal_fix(VALUE self)
{
    ENTER(5);
    Real *c, *a;
    size_t mx;

    GUARD_OBJ(a, GetVpValue(self, 1));
    mx = a-&gt;Prec *(VpBaseFig() + 1);
    GUARD_OBJ(c, VpCreateRbObject(mx, &quot;0&quot;));
    VpActiveRound(c, a, VP_ROUND_DOWN, 0); /* 0: round off */
    return ToValue(c);
}
            </pre> 
            </div><!-- fix-source -->
            
          </div>

          

          
        </div><!-- fix-method -->
      
        <div id="floor-method" class="method-detail ">
          <a name="method-i-floor"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">floor(n)</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Return the largest integer less than or equal to the value, as a <a href="BigDecimal.html"><code>BigDecimal</code></a>.</p>

<pre class="ruby"><span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&#39;3.14159&#39;</span>).<span class="ruby-identifier">floor</span> <span class="ruby-comment">#=&gt; 3</span>
<span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&#39;-9.1&#39;</span>).<span class="ruby-identifier">floor</span> <span class="ruby-comment">#=&gt; -10</span>
</pre>

<p>If n is specified and positive, the fractional part of the result has no more than that many digits.</p>

<p>If n is specified and negative, at least that many digits to the left of the decimal point will be 0 in the result.</p>

<pre class="ruby"><span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&#39;3.14159&#39;</span>).<span class="ruby-identifier">floor</span>(<span class="ruby-value">3</span>) <span class="ruby-comment">#=&gt; 3.141</span>
<span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&#39;13345.234&#39;</span>).<span class="ruby-identifier">floor</span>(<span class="ruby-value">-2</span>) <span class="ruby-comment">#=&gt; 13300.0</span>
</pre>
            

            
            <div class="method-source-code" id="floor-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
BigDecimal_floor(int argc, VALUE *argv, VALUE self)
{
    ENTER(5);
    Real *c, *a;
    int iLoc;
    VALUE vLoc;
    size_t mx, pl = VpSetPrecLimit(0);

    if (rb_scan_args(argc, argv, &quot;01&quot;, &amp;vLoc)==0) {
        iLoc = 0;
    }
    else {
        iLoc = NUM2INT(vLoc);
    }

    GUARD_OBJ(a, GetVpValue(self, 1));
    mx = a-&gt;Prec * (VpBaseFig() + 1);
    GUARD_OBJ(c, VpCreateRbObject(mx, &quot;0&quot;));
    VpSetPrecLimit(pl);
    VpActiveRound(c, a, VP_ROUND_FLOOR, iLoc);
#ifdef BIGDECIMAL_DEBUG
    VPrint(stderr, &quot;floor: c=%\n&quot;, c);
#endif
    if (argc == 0) {
        return BigDecimal_to_i(ToValue(c));
    }
    return ToValue(c);
}
            </pre> 
            </div><!-- floor-source -->
            
          </div>

          

          
        </div><!-- floor-method -->
      
        <div id="frac-method" class="method-detail ">
          <a name="method-i-frac"></a>

          
          <div class="method-heading">
            <span class="method-name">frac</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          
          <div>
  
            
            <p>Return the fractional part of the number, as a <a href="BigDecimal.html"><code>BigDecimal</code></a>.</p>
            

            
            <div class="method-source-code" id="frac-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
BigDecimal_frac(VALUE self)
{
    ENTER(5);
    Real *c, *a;
    size_t mx;

    GUARD_OBJ(a, GetVpValue(self, 1));
    mx = a-&gt;Prec * (VpBaseFig() + 1);
    GUARD_OBJ(c, VpCreateRbObject(mx, &quot;0&quot;));
    VpFrac(c, a);
    return ToValue(c);
}
            </pre> 
            </div><!-- frac-source -->
            
          </div>

          

          
        </div><!-- frac-method -->
      
        <div id="hash-method" class="method-detail ">
          <a name="method-i-hash"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">hash</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Creates a hash for this <a href="BigDecimal.html"><code>BigDecimal</code></a>.</p>

<p>Two BigDecimals with equal sign, fractional part and exponent have the same hash.</p>
            

            
            <div class="method-source-code" id="hash-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
BigDecimal_hash(VALUE self)
{
    ENTER(1);
    Real *p;
    st_index_t hash;

    GUARD_OBJ(p, GetVpValue(self, 1));
    hash = (st_index_t)p-&gt;sign;
    /* hash!=2: the case for 0(1),NaN(0) or +-Infinity(3) is sign itself */
    if(hash == 2 || hash == (st_index_t)-2) {
        hash ^= rb_memhash(p-&gt;frac, sizeof(BDIGIT)*p-&gt;Prec);
        hash += p-&gt;exponent;
    }
    return ST2FIX(hash);
}
            </pre> 
            </div><!-- hash-source -->
            
          </div>

          

          
        </div><!-- hash-method -->
      
        <div id="infinite-3F-method" class="method-detail ">
          <a name="method-i-infinite-3F"></a>

          
          <div class="method-heading">
            <span class="method-name">infinite?</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          
          <div>
  
            
            <p>Returns nil, -1, or +1 depending on whether the value is finite, -Infinity, or +Infinity.</p>
            

            
            <div class="method-source-code" id="infinite-3F-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
BigDecimal_IsInfinite(VALUE self)
{
    Real *p = GetVpValue(self, 1);
    if (VpIsPosInf(p)) return INT2FIX(1);
    if (VpIsNegInf(p)) return INT2FIX(-1);
    return Qnil;
}
            </pre> 
            </div><!-- infinite-3F-source -->
            
          </div>

          

          
        </div><!-- infinite-3F-method -->
      
        <div id="inspect-method" class="method-detail ">
          <a name="method-i-inspect"></a>

          
          <div class="method-heading">
            <span class="method-name">inspect</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          
          <div>
  
            
            <p>Returns a string representation of self.</p>

<pre class="ruby"><span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&quot;1234.5678&quot;</span>).<span class="ruby-identifier">inspect</span>
  <span class="ruby-comment">#=&gt; &quot;0.12345678e4&quot;</span>
</pre>
            

            
            <div class="method-source-code" id="inspect-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
BigDecimal_inspect(VALUE self)
{
    ENTER(5);
    Real *vp;
    volatile VALUE str;
    size_t nc;

    GUARD_OBJ(vp, GetVpValue(self, 1));
    nc = VpNumOfChars(vp, &quot;E&quot;);

    str = rb_str_new(0, nc);
    VpToString(vp, RSTRING_PTR(str), 0, 0);
    rb_str_resize(str, strlen(RSTRING_PTR(str)));
    return str;
}
            </pre> 
            </div><!-- inspect-source -->
            
          </div>

          

          
        </div><!-- inspect-method -->
      
        <div id="modulo-method" class="method-detail ">
          <a name="method-i-modulo"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">modulo(b)</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the modulus from dividing by b.</p>

<p>See <a href="BigDecimal.html#method-i-divmod"><code>BigDecimal#divmod</code></a>.</p>
            

            
            <div class="method-source-code" id="modulo-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
BigDecimal_mod(VALUE self, VALUE r) 
            </pre> 
            </div><!-- modulo-source -->
            
          </div>

          

          
        </div><!-- modulo-method -->
      
        <div id="mult-method" class="method-detail ">
          <a name="method-i-mult"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">mult(value, digits)</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Multiply by the specified value.</p>

<p>e.g.</p>

<pre class="ruby"><span class="ruby-identifier">c</span> = <span class="ruby-identifier">a</span>.<span class="ruby-identifier">mult</span>(<span class="ruby-identifier">b</span>,<span class="ruby-identifier">n</span>)
<span class="ruby-identifier">c</span> = <span class="ruby-identifier">a</span> <span class="ruby-operator">*</span> <span class="ruby-identifier">b</span>
</pre>
<dl class="rdoc-list note-list"><dt>digits
<dd>
<p>If specified and less than the number of significant digits of the result, the result is rounded to that number of digits, according to <a href="BigDecimal.html#method-c-mode"><code>BigDecimal.mode</code></a>.</p>
</dd></dl>
            

            
            <div class="method-source-code" id="mult-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
BigDecimal_mult2(VALUE self, VALUE b, VALUE n)
{
    ENTER(2);
    Real *cv;
    SIGNED_VALUE mx = GetPrecisionInt(n);
    if (mx == 0) return BigDecimal_mult(self, b);
    else {
        size_t pl = VpSetPrecLimit(0);
        VALUE   c = BigDecimal_mult(self, b);
        VpSetPrecLimit(pl);
        GUARD_OBJ(cv, GetVpValue(c, 1));
        VpLeftRound(cv, VpGetRoundMode(), mx);
        return ToValue(cv);
    }
}
            </pre> 
            </div><!-- mult-source -->
            
          </div>

          

          
        </div><!-- mult-method -->
      
        <div id="nan-3F-method" class="method-detail ">
          <a name="method-i-nan-3F"></a>

          
          <div class="method-heading">
            <span class="method-name">nan?</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          
          <div>
  
            
            <p>Returns True if the value is Not a Number.</p>
            

            
            <div class="method-source-code" id="nan-3F-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
BigDecimal_IsNaN(VALUE self)
{
    Real *p = GetVpValue(self, 1);
    if (VpIsNaN(p))  return Qtrue;
    return Qfalse;
}
            </pre> 
            </div><!-- nan-3F-source -->
            
          </div>

          

          
        </div><!-- nan-3F-method -->
      
        <div id="nonzero-3F-method" class="method-detail ">
          <a name="method-i-nonzero-3F"></a>

          
          <div class="method-heading">
            <span class="method-name">nonzero?</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          
          <div>
  
            
            <p>Returns self if the value is non-zero, nil otherwise.</p>
            

            
            <div class="method-source-code" id="nonzero-3F-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
BigDecimal_nonzero(VALUE self)
{
    Real *a = GetVpValue(self, 1);
    return VpIsZero(a) ? Qnil : self;
}
            </pre> 
            </div><!-- nonzero-3F-source -->
            
          </div>

          

          
        </div><!-- nonzero-3F-method -->
      
        <div id="power-method" class="method-detail ">
          <a name="method-i-power"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">power(n)</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">power(n, prec)</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the value raised to the power of n.</p>

<p>Note that n must be an <a href="Integer.html"><code>Integer</code></a>.</p>

<p>Also available as the operator **.</p>
            

            
            <div class="method-source-code" id="power-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
BigDecimal_power(int argc, VALUE*argv, VALUE self)
{
    ENTER(5);
    VALUE vexp, prec;
    Real* exp = NULL;
    Real *x, *y;
    ssize_t mp, ma, n;
    SIGNED_VALUE int_exp;
    double d;

    rb_scan_args(argc, argv, &quot;11&quot;, &amp;vexp, &amp;prec);

    GUARD_OBJ(x, GetVpValue(self, 1));
    n = NIL_P(prec) ? (ssize_t)(x-&gt;Prec*VpBaseFig()) : NUM2SSIZET(prec);

    if (VpIsNaN(x)) {
        y = VpCreateRbObject(n, &quot;0&quot;);
        RB_GC_GUARD(y-&gt;obj);
        VpSetNaN(y);
        return ToValue(y);
    }

  retry:
    switch (TYPE(vexp)) {
      case T_FIXNUM:
        break;

      case T_BIGNUM:
        break;

      case T_FLOAT:
        d = RFLOAT_VALUE(vexp);
        if (d == round(d)) {
            if (FIXABLE(d)) {
                vexp = LONG2FIX((long)d);
            }
            else {
                vexp = rb_dbl2big(d);
            }
            goto retry;
        }
        exp = GetVpValueWithPrec(vexp, DBL_DIG+1, 1);
        break;

      case T_RATIONAL:
        if (is_zero(rb_rational_num(vexp))) {
            if (is_positive(vexp)) {
                vexp = INT2FIX(0);
                goto retry;
            }
        }
        else if (is_one(rb_rational_den(vexp))) {
            vexp = rb_rational_num(vexp);
            goto retry;
        }
        exp = GetVpValueWithPrec(vexp, n, 1);
        break;

      case T_DATA:
        if (is_kind_of_BigDecimal(vexp)) {
            VALUE zero = INT2FIX(0);
            VALUE rounded = BigDecimal_round(1, &amp;zero, vexp);
            if (RTEST(BigDecimal_eq(vexp, rounded))) {
                vexp = BigDecimal_to_i(vexp);
                goto retry;
            }
            exp = DATA_PTR(vexp);
            break;
        }
        /* fall through */
      default:
        rb_raise(rb_eTypeError,
                 &quot;wrong argument type %&quot;PRIsVALUE&quot; (expected scalar Numeric)&quot;,
                 RB_OBJ_CLASSNAME(vexp));
    }

    if (VpIsZero(x)) {
        if (is_negative(vexp)) {
            y = VpCreateRbObject(n, &quot;#0&quot;);
            RB_GC_GUARD(y-&gt;obj);
            if (BIGDECIMAL_NEGATIVE_P(x)) {
                if (is_integer(vexp)) {
                    if (is_even(vexp)) {
                        /* (-0) ** (-even_integer)  -&gt; Infinity */
                        VpSetPosInf(y);
                    }
                    else {
                        /* (-0) ** (-odd_integer)  -&gt; -Infinity */
                        VpSetNegInf(y);
                    }
                }
                else {
                    /* (-0) ** (-non_integer)  -&gt; Infinity */
                    VpSetPosInf(y);
                }
            }
            else {
                /* (+0) ** (-num)  -&gt; Infinity */
                VpSetPosInf(y);
            }
            return ToValue(y);
        }
        else if (is_zero(vexp)) {
            return ToValue(VpCreateRbObject(n, &quot;1&quot;));
        }
        else {
            return ToValue(VpCreateRbObject(n, &quot;0&quot;));
        }
    }

    if (is_zero(vexp)) {
        return ToValue(VpCreateRbObject(n, &quot;1&quot;));
    }
    else if (is_one(vexp)) {
        return self;
    }

    if (VpIsInf(x)) {
        if (is_negative(vexp)) {
            if (BIGDECIMAL_NEGATIVE_P(x)) {
                if (is_integer(vexp)) {
                    if (is_even(vexp)) {
                        /* (-Infinity) ** (-even_integer) -&gt; +0 */
                        return ToValue(VpCreateRbObject(n, &quot;0&quot;));
                    }
                    else {
                        /* (-Infinity) ** (-odd_integer) -&gt; -0 */
                        return ToValue(VpCreateRbObject(n, &quot;-0&quot;));
                    }
                }
                else {
                    /* (-Infinity) ** (-non_integer) -&gt; -0 */
                    return ToValue(VpCreateRbObject(n, &quot;-0&quot;));
                }
            }
            else {
                return ToValue(VpCreateRbObject(n, &quot;0&quot;));
            }
        }
        else {
            y = VpCreateRbObject(n, &quot;0&quot;);
            if (BIGDECIMAL_NEGATIVE_P(x)) {
                if (is_integer(vexp)) {
                    if (is_even(vexp)) {
                        VpSetPosInf(y);
                    }
                    else {
                        VpSetNegInf(y);
                    }
                }
                else {
                    /* TODO: support complex */
                    rb_raise(rb_eMathDomainError,
                             &quot;a non-integral exponent for a negative base&quot;);
                }
            }
            else {
                VpSetPosInf(y);
            }
            return ToValue(y);
        }
    }

    if (exp != NULL) {
        return rmpd_power_by_big_decimal(x, exp, n);
    }
    else if (RB_TYPE_P(vexp, T_BIGNUM)) {
        VALUE abs_value = BigDecimal_abs(self);
        if (is_one(abs_value)) {
            return ToValue(VpCreateRbObject(n, &quot;1&quot;));
        }
        else if (RTEST(rb_funcall(abs_value, &#39;&lt;&#39;, 1, INT2FIX(1)))) {
            if (is_negative(vexp)) {
                y = VpCreateRbObject(n, &quot;0&quot;);
                if (is_even(vexp)) {
                    VpSetInf(y, VpGetSign(x));
                }
                else {
                    VpSetInf(y, -VpGetSign(x));
                }
                return ToValue(y);
            }
            else if (BIGDECIMAL_NEGATIVE_P(x) &amp;&amp; is_even(vexp)) {
                return ToValue(VpCreateRbObject(n, &quot;-0&quot;));
            }
            else {
                return ToValue(VpCreateRbObject(n, &quot;0&quot;));
            }
        }
        else {
            if (is_positive(vexp)) {
                y = VpCreateRbObject(n, &quot;0&quot;);
                if (is_even(vexp)) {
                    VpSetInf(y, VpGetSign(x));
                }
                else {
                    VpSetInf(y, -VpGetSign(x));
                }
                return ToValue(y);
            }
            else if (BIGDECIMAL_NEGATIVE_P(x) &amp;&amp; is_even(vexp)) {
                return ToValue(VpCreateRbObject(n, &quot;-0&quot;));
            }
            else {
                return ToValue(VpCreateRbObject(n, &quot;0&quot;));
            }
        }
    }

    int_exp = FIX2LONG(vexp);
    ma = int_exp;
    if (ma &lt;  0) ma = -ma;
    if (ma == 0) ma = 1;

    if (VpIsDef(x)) {
        mp = x-&gt;Prec * (VpBaseFig() + 1);
        GUARD_OBJ(y, VpCreateRbObject(mp * (ma + 1), &quot;0&quot;));
    }
    else {
        GUARD_OBJ(y, VpCreateRbObject(1, &quot;0&quot;));
    }
    VpPower(y, x, int_exp);
    if (!NIL_P(prec) &amp;&amp; VpIsDef(y)) {
        VpMidRound(y, VpGetRoundMode(), n);
    }
    return ToValue(y);
}
            </pre> 
            </div><!-- power-source -->
            
          </div>

          

          
        </div><!-- power-method -->
      
        <div id="precs-method" class="method-detail ">
          <a name="method-i-precs"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">precs  &rarr;  array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns an Array of two <a href="Integer.html"><code>Integer</code></a> values.</p>

<p>The first value is the current number of significant digits in the <a href="BigDecimal.html"><code>BigDecimal</code></a>. The second value is the maximum number of significant digits for the <a href="BigDecimal.html"><code>BigDecimal</code></a>.</p>

<pre class="ruby"><span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&#39;5&#39;</span>).<span class="ruby-identifier">precs</span> <span class="ruby-comment">#=&gt; [9, 18]</span>
</pre>
            

            
            <div class="method-source-code" id="precs-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
BigDecimal_prec(VALUE self)
{
    ENTER(1);
    Real *p;
    VALUE obj;

    GUARD_OBJ(p, GetVpValue(self, 1));
    obj = rb_assoc_new(INT2NUM(p-&gt;Prec*VpBaseFig()),
                       INT2NUM(p-&gt;MaxPrec*VpBaseFig()));
    return obj;
}
            </pre> 
            </div><!-- precs-source -->
            
          </div>

          

          
        </div><!-- precs-method -->
      
        <div id="quo-method" class="method-detail ">
          <a name="method-i-quo"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">quo(value)  &rarr; bigdecimal</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Divide by the specified value.</p>

<p>See <a href="BigDecimal.html#method-i-div"><code>BigDecimal#div</code></a>.</p>
            

            
            <div class="method-source-code" id="quo-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
BigDecimal_div(VALUE self, VALUE r)
/* For c = self/r: with round operation */
{
    ENTER(5);
    Real *c=NULL, *res=NULL, *div = NULL;
    r = BigDecimal_divide(&amp;c, &amp;res, &amp;div, self, r);
    if (!NIL_P(r)) return r; /* coerced by other */
    SAVE(c); SAVE(res); SAVE(div);
    /* a/b = c + r/b */
    /* c xxxxx
       r 00000yyyyy  ==&gt; (y/b)*BASE &gt;= HALF_BASE
     */
    /* Round */
    if (VpHasVal(div)) { /* frac[0] must be zero for NaN,INF,Zero */
        VpInternalRound(c, 0, c-&gt;frac[c-&gt;Prec-1], (BDIGIT)(VpBaseVal() * (BDIGIT_DBL)res-&gt;frac[0] / div-&gt;frac[0]));
    }
    return ToValue(c);
}
            </pre> 
            </div><!-- quo-source -->
            
          </div>

          

          
        </div><!-- quo-method -->
      
        <div id="remainder-method" class="method-detail ">
          <a name="method-i-remainder"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">remainder(value)</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the remainder from dividing by the value.</p>

<p>x.remainder(y) means x-y*(x/y).truncate</p>
            

            
            <div class="method-source-code" id="remainder-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
BigDecimal_remainder(VALUE self, VALUE r) /* remainder */
{
    VALUE  f;
    Real  *d, *rv = 0;
    f = BigDecimal_divremain(self, r, &amp;d, &amp;rv);
    if (!NIL_P(f)) return f;
    return ToValue(rv);
}
            </pre> 
            </div><!-- remainder-source -->
            
          </div>

          

          
        </div><!-- remainder-method -->
      
        <div id="round-method" class="method-detail ">
          <a name="method-i-round"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">round(n, mode)</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Round to the nearest integer (by default), returning the result as a <a href="BigDecimal.html"><code>BigDecimal</code></a> if n is specified, or as an <a href="Integer.html"><code>Integer</code></a> if it isn&#39;t.</p>

<pre class="ruby"><span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&#39;3.14159&#39;</span>).<span class="ruby-identifier">round</span> <span class="ruby-comment">#=&gt; 3</span>
<span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&#39;8.7&#39;</span>).<span class="ruby-identifier">round</span> <span class="ruby-comment">#=&gt; 9</span>
<span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&#39;-9.9&#39;</span>).<span class="ruby-identifier">round</span> <span class="ruby-comment">#=&gt; -10</span>

<span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&#39;3.14159&#39;</span>).<span class="ruby-identifier">round</span>(<span class="ruby-value">2</span>).<span class="ruby-identifier">class</span>.<span class="ruby-identifier">name</span> <span class="ruby-comment">#=&gt; &quot;BigDecimal&quot;</span>
<span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&#39;3.14159&#39;</span>).<span class="ruby-identifier">round</span>.<span class="ruby-identifier">class</span>.<span class="ruby-identifier">name</span> <span class="ruby-comment">#=&gt; &quot;Integer&quot;</span>
</pre>

<p>If n is specified and positive, the fractional part of the result has no more than that many digits.</p>

<p>If n is specified and negative, at least that many digits to the left of the decimal point will be 0 in the result.</p>

<pre class="ruby"><span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&#39;3.14159&#39;</span>).<span class="ruby-identifier">round</span>(<span class="ruby-value">3</span>) <span class="ruby-comment">#=&gt; 3.142</span>
<span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&#39;13345.234&#39;</span>).<span class="ruby-identifier">round</span>(<span class="ruby-value">-2</span>) <span class="ruby-comment">#=&gt; 13300.0</span>
</pre>

<p>The value of the optional mode argument can be used to determine how rounding is performed; see <a href="BigDecimal.html#method-c-mode"><code>BigDecimal.mode</code></a>.</p>
            

            
            <div class="method-source-code" id="round-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
BigDecimal_round(int argc, VALUE *argv, VALUE self)
{
    ENTER(5);
    Real   *c, *a;
    int    iLoc = 0;
    VALUE  vLoc;
    VALUE  vRound;
    size_t mx, pl;

    unsigned short sw = VpGetRoundMode();

    switch (rb_scan_args(argc, argv, &quot;02&quot;, &amp;vLoc, &amp;vRound)) {
      case 0:
        iLoc = 0;
        break;
      case 1:
        if (RB_TYPE_P(vLoc, T_HASH)) {
            sw = check_rounding_mode_option(vLoc);
        }
        else {
            iLoc = NUM2INT(vLoc);
        }
        break;
      case 2:
        iLoc = NUM2INT(vLoc);
        if (RB_TYPE_P(vRound, T_HASH)) {
            sw = check_rounding_mode_option(vRound);
        }
        else {
            sw = check_rounding_mode(vRound);
        }
        break;
      default:
        break;
    }

    pl = VpSetPrecLimit(0);
    GUARD_OBJ(a, GetVpValue(self, 1));
    mx = a-&gt;Prec * (VpBaseFig() + 1);
    GUARD_OBJ(c, VpCreateRbObject(mx, &quot;0&quot;));
    VpSetPrecLimit(pl);
    VpActiveRound(c, a, sw, iLoc);
    if (argc == 0) {
        return BigDecimal_to_i(ToValue(c));
    }
    return ToValue(c);
}
            </pre> 
            </div><!-- round-source -->
            
          </div>

          

          
        </div><!-- round-method -->
      
        <div id="sign-method" class="method-detail ">
          <a name="method-i-sign"></a>

          
          <div class="method-heading">
            <span class="method-name">sign</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          
          <div>
  
            
            <p>Returns the sign of the value.</p>

<p>Returns a positive value if &gt; 0, a negative value if &lt; 0, and a zero if == 0.</p>

<p>The specific value returned indicates the type and sign of the <a href="BigDecimal.html"><code>BigDecimal</code></a>, as follows:</p>
<dl class="rdoc-list note-list"><dt><a href="BigDecimal.html#SIGN_NaN"><code>BigDecimal::SIGN_NaN</code></a>
<dd>
<p>value is Not a Number</p>
</dd><dt><a href="BigDecimal.html#SIGN_POSITIVE_ZERO"><code>BigDecimal::SIGN_POSITIVE_ZERO</code></a>
<dd>
<p>value is +0</p>
</dd><dt><a href="BigDecimal.html#SIGN_NEGATIVE_ZERO"><code>BigDecimal::SIGN_NEGATIVE_ZERO</code></a>
<dd>
<p>value is -0</p>
</dd><dt><a href="BigDecimal.html#SIGN_POSITIVE_INFINITE"><code>BigDecimal::SIGN_POSITIVE_INFINITE</code></a>
<dd>
<p>value is +Infinity</p>
</dd><dt><a href="BigDecimal.html#SIGN_NEGATIVE_INFINITE"><code>BigDecimal::SIGN_NEGATIVE_INFINITE</code></a>
<dd>
<p>value is -Infinity</p>
</dd><dt><a href="BigDecimal.html#SIGN_POSITIVE_FINITE"><code>BigDecimal::SIGN_POSITIVE_FINITE</code></a>
<dd>
<p>value is positive</p>
</dd><dt><a href="BigDecimal.html#SIGN_NEGATIVE_FINITE"><code>BigDecimal::SIGN_NEGATIVE_FINITE</code></a>
<dd>
<p>value is negative</p>
</dd></dl>
            

            
            <div class="method-source-code" id="sign-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
BigDecimal_sign(VALUE self)
{ /* sign */
    int s = GetVpValue(self, 1)-&gt;sign;
    return INT2FIX(s);
}
            </pre> 
            </div><!-- sign-source -->
            
          </div>

          

          
        </div><!-- sign-method -->
      
        <div id="split-method" class="method-detail ">
          <a name="method-i-split"></a>

          
          <div class="method-heading">
            <span class="method-name">split</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          
          <div>
  
            
            <p>Splits a <a href="BigDecimal.html"><code>BigDecimal</code></a> number into four parts, returned as an array of values.</p>

<p>The first value represents the sign of the <a href="BigDecimal.html"><code>BigDecimal</code></a>, and is -1 or 1, or 0 if the <a href="BigDecimal.html"><code>BigDecimal</code></a> is Not a Number.</p>

<p>The second value is a string representing the significant digits of the <a href="BigDecimal.html"><code>BigDecimal</code></a>, with no leading zeros.</p>

<p>The third value is the base used for arithmetic (currently always 10) as an <a href="Integer.html"><code>Integer</code></a>.</p>

<p>The fourth value is an <a href="Integer.html"><code>Integer</code></a> exponent.</p>

<p>If the <a href="BigDecimal.html"><code>BigDecimal</code></a> can be represented as 0.xxxxxx*10**n, then xxxxxx is the string of significant digits with no leading zeros, and n is the exponent.</p>

<p>From these values, you can translate a <a href="BigDecimal.html"><code>BigDecimal</code></a> to a float as follows:</p>

<pre class="ruby"><span class="ruby-identifier">sign</span>, <span class="ruby-identifier">significant_digits</span>, <span class="ruby-identifier">base</span>, <span class="ruby-identifier">exponent</span> = <span class="ruby-identifier">a</span>.<span class="ruby-identifier">split</span>
<span class="ruby-identifier">f</span> = <span class="ruby-identifier">sign</span> <span class="ruby-operator">*</span> <span class="ruby-node">&quot;0.#{significant_digits}&quot;</span>.<span class="ruby-identifier">to_f</span> <span class="ruby-operator">*</span> (<span class="ruby-identifier">base</span> <span class="ruby-operator">**</span> <span class="ruby-identifier">exponent</span>)
</pre>

<p>(Note that the <a href="BigDecimal.html#method-i-to_f"><code>to_f</code></a> method is provided as a more convenient way to translate a <a href="BigDecimal.html"><code>BigDecimal</code></a> to a <a href="Float.html"><code>Float</code></a>.)</p>
            

            
            <div class="method-source-code" id="split-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
BigDecimal_split(VALUE self)
{
    ENTER(5);
    Real *vp;
    VALUE obj,str;
    ssize_t e, s;
    char *psz1;

    GUARD_OBJ(vp, GetVpValue(self, 1));
    str = rb_str_new(0, VpNumOfChars(vp, &quot;E&quot;));
    psz1 = RSTRING_PTR(str);
    VpSzMantissa(vp, psz1);
    s = 1;
    if(psz1[0] == &#39;-&#39;) {
        size_t len = strlen(psz1 + 1);

        memmove(psz1, psz1 + 1, len);
        psz1[len] = &#39;\0&#39;;
        s = -1;
    }
    if (psz1[0] == &#39;N&#39;) s = 0; /* NaN */
    e = VpExponent10(vp);
    obj = rb_ary_new2(4);
    rb_ary_push(obj, INT2FIX(s));
    rb_ary_push(obj, str);
    rb_str_resize(str, strlen(psz1));
    rb_ary_push(obj, INT2FIX(10));
    rb_ary_push(obj, INT2NUM(e));
    return obj;
}
            </pre> 
            </div><!-- split-source -->
            
          </div>

          

          
        </div><!-- split-method -->
      
        <div id="sqrt-method" class="method-detail ">
          <a name="method-i-sqrt"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">sqrt(n)</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the square root of the value.</p>

<p>Result has at least n significant digits.</p>
            

            
            <div class="method-source-code" id="sqrt-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
BigDecimal_sqrt(VALUE self, VALUE nFig)
{
    ENTER(5);
    Real *c, *a;
    size_t mx, n;

    GUARD_OBJ(a, GetVpValue(self, 1));
    mx = a-&gt;Prec * (VpBaseFig() + 1);

    n = GetPrecisionInt(nFig) + VpDblFig() + BASE_FIG;
    if (mx &lt;= n) mx = n;
    GUARD_OBJ(c, VpCreateRbObject(mx, &quot;0&quot;));
    VpSqrt(c, a);
    return ToValue(c);
}
            </pre> 
            </div><!-- sqrt-source -->
            
          </div>

          

          
        </div><!-- sqrt-method -->
      
        <div id="sub-method" class="method-detail ">
          <a name="method-i-sub"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">sub(value, digits)  &rarr; bigdecimal</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Subtract the specified value.</p>

<p>e.g.</p>

<pre class="ruby"><span class="ruby-identifier">c</span> = <span class="ruby-identifier">a</span>.<span class="ruby-identifier">sub</span>(<span class="ruby-identifier">b</span>,<span class="ruby-identifier">n</span>)
</pre>
<dl class="rdoc-list note-list"><dt>digits
<dd>
<p>If specified and less than the number of significant digits of the result, the result is rounded to that number of digits, according to <a href="BigDecimal.html#method-c-mode"><code>BigDecimal.mode</code></a>.</p>
</dd></dl>
            

            
            <div class="method-source-code" id="sub-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
BigDecimal_sub2(VALUE self, VALUE b, VALUE n)
{
    ENTER(2);
    Real *cv;
    SIGNED_VALUE mx = GetPrecisionInt(n);
    if (mx == 0) return BigDecimal_sub(self, b);
    else {
        size_t pl = VpSetPrecLimit(0);
        VALUE   c = BigDecimal_sub(self, b);
        VpSetPrecLimit(pl);
        GUARD_OBJ(cv, GetVpValue(c, 1));
        VpLeftRound(cv, VpGetRoundMode(), mx);
        return ToValue(cv);
    }
}
            </pre> 
            </div><!-- sub-source -->
            
          </div>

          

          
        </div><!-- sub-method -->
      
        <div id="to_d-method" class="method-detail ">
          <a name="method-i-to_d"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">to_d &rarr; bigdecimal</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns self.</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&#39;bigdecimal/util&#39;</span>

<span class="ruby-identifier">d</span> = <span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&quot;3.14&quot;</span>)
<span class="ruby-identifier">d</span>.<span class="ruby-identifier">to_d</span>                       <span class="ruby-comment"># =&gt; 0.314e1</span>
</pre>
            

            
            <div class="method-source-code" id="to_d-source">
              <pre> <!-- method.markup_code 290 -->
               <span class="ruby-comment"># File bigdecimal/lib/bigdecimal/util.rb, line 106</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_d</span>
  <span class="ruby-keyword">self</span>
<span class="ruby-keyword">end</span>
            </pre> 
            </div><!-- to_d-source -->
            
          </div>

          

          
        </div><!-- to_d-method -->
      
        <div id="to_digits-method" class="method-detail ">
          <a name="method-i-to_digits"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">to_digits &rarr; string</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Converts a <a href="BigDecimal.html"><code>BigDecimal</code></a> to a <a href="String.html"><code>String</code></a> of the form â€œnnnnnn.mmmâ€. This method is deprecated; use <a href="BigDecimal.html#method-i-to_s"><code>BigDecimal#to_s</code></a>(â€œFâ€) instead.</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&#39;bigdecimal/util&#39;</span>

<span class="ruby-identifier">d</span> = <span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&quot;3.14&quot;</span>)
<span class="ruby-identifier">d</span>.<span class="ruby-identifier">to_digits</span>                  <span class="ruby-comment"># =&gt; &quot;3.14&quot;</span>
</pre>
            

            
            <div class="method-source-code" id="to_digits-source">
              <pre> <!-- method.markup_code 290 -->
               <span class="ruby-comment"># File bigdecimal/lib/bigdecimal/util.rb, line 86</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_digits</span>
  <span class="ruby-keyword">if</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">nan?</span> <span class="ruby-operator">||</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">infinite?</span> <span class="ruby-operator">||</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">zero?</span>
    <span class="ruby-keyword">self</span>.<span class="ruby-identifier">to_s</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">i</span>       = <span class="ruby-keyword">self</span>.<span class="ruby-identifier">to_i</span>.<span class="ruby-identifier">to_s</span>
    <span class="ruby-identifier">_</span>,<span class="ruby-identifier">f</span>,<span class="ruby-identifier">_</span>,<span class="ruby-identifier">z</span> = <span class="ruby-keyword">self</span>.<span class="ruby-identifier">frac</span>.<span class="ruby-identifier">split</span>
    <span class="ruby-identifier">i</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;.&quot;</span> <span class="ruby-operator">+</span> (<span class="ruby-string">&quot;0&quot;</span><span class="ruby-operator">*</span>(<span class="ruby-operator">-</span><span class="ruby-identifier">z</span>)) <span class="ruby-operator">+</span> <span class="ruby-identifier">f</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
            </pre> 
            </div><!-- to_digits-source -->
            
          </div>

          

          
        </div><!-- to_digits-method -->
      
        <div id="to_f-method" class="method-detail ">
          <a name="method-i-to_f"></a>

          
          <div class="method-heading">
            <span class="method-name">to_f</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          
          <div>
  
            
            <p>Returns a new <a href="Float.html"><code>Float</code></a> object having approximately the same value as the <a href="BigDecimal.html"><code>BigDecimal</code></a> number. Normal accuracy limits and built-in errors of binary <a href="Float.html"><code>Float</code></a> arithmetic apply.</p>
            

            
            <div class="method-source-code" id="to_f-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
BigDecimal_to_f(VALUE self)
{
    ENTER(1);
    Real *p;
    double d;
    SIGNED_VALUE e;
    char *buf;
    volatile VALUE str;

    GUARD_OBJ(p, GetVpValue(self, 1));
    if (VpVtoD(&amp;d, &amp;e, p) != 1)
        return rb_float_new(d);
    if (e &gt; (SIGNED_VALUE)(DBL_MAX_10_EXP+BASE_FIG))
        goto overflow;
    if (e &lt; (SIGNED_VALUE)(DBL_MIN_10_EXP-BASE_FIG))
        goto underflow;

    str = rb_str_new(0, VpNumOfChars(p, &quot;E&quot;));
    buf = RSTRING_PTR(str);
    VpToString(p, buf, 0, 0);
    errno = 0;
    d = strtod(buf, 0);
    if (errno == ERANGE) {
        if (d == 0.0) goto underflow;
        if (fabs(d) &gt;= HUGE_VAL) goto overflow;
    }
    return rb_float_new(d);

overflow:
    VpException(VP_EXCEPTION_OVERFLOW, &quot;BigDecimal to Float conversion&quot;, 0);
    if (BIGDECIMAL_NEGATIVE_P(p))
        return rb_float_new(VpGetDoubleNegInf());
    else
        return rb_float_new(VpGetDoublePosInf());

underflow:
    VpException(VP_EXCEPTION_UNDERFLOW, &quot;BigDecimal to Float conversion&quot;, 0);
    if (BIGDECIMAL_NEGATIVE_P(p))
        return rb_float_new(-0.0);
    else
        return rb_float_new(0.0);
}
            </pre> 
            </div><!-- to_f-source -->
            
          </div>

          

          
        </div><!-- to_f-method -->
      
        <div id="to_i-method" class="method-detail ">
          <a name="method-i-to_i"></a>

          
          <div class="method-heading">
            <span class="method-name">to_i</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          
          <div>
  
            
            <p>Returns the value as an <a href="Integer.html"><code>Integer</code></a>.</p>

<p>If the <a href="BigDecimal.html"><code>BigDecimal</code></a> is infinity or NaN, raises FloatDomainError.</p>
            

            
            <div class="method-source-code" id="to_i-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
BigDecimal_to_i(VALUE self)
{
    ENTER(5);
    ssize_t e, nf;
    Real *p;

    GUARD_OBJ(p, GetVpValue(self, 1));
    BigDecimal_check_num(p);

    e = VpExponent10(p);
    if (e &lt;= 0) return INT2FIX(0);
    nf = VpBaseFig();
    if (e &lt;= nf) {
        return LONG2NUM((long)(VpGetSign(p) * (BDIGIT_DBL_SIGNED)p-&gt;frac[0]));
    }
    else {
        VALUE a = BigDecimal_split(self);
        VALUE digits = RARRAY_AREF(a, 1);
        VALUE numerator = rb_funcall(digits, rb_intern(&quot;to_i&quot;), 0);
        VALUE ret;
        ssize_t dpower = e - (ssize_t)RSTRING_LEN(digits);

        if (BIGDECIMAL_NEGATIVE_P(p)) {
            numerator = rb_funcall(numerator, &#39;*&#39;, 1, INT2FIX(-1));
        }
        if (dpower &lt; 0) {
            ret = rb_funcall(numerator, rb_intern(&quot;div&quot;), 1,
                              rb_funcall(INT2FIX(10), rb_intern(&quot;**&quot;), 1,
                                         INT2FIX(-dpower)));
        }
        else {
            ret = rb_funcall(numerator, &#39;*&#39;, 1,
                             rb_funcall(INT2FIX(10), rb_intern(&quot;**&quot;), 1,
                                        INT2FIX(dpower)));
        }
        if (RB_TYPE_P(ret, T_FLOAT)) {
            rb_raise(rb_eFloatDomainError, &quot;Infinity&quot;);
        }
        return ret;
    }
}
            </pre> 
            </div><!-- to_i-source -->
            
          </div>

          

          
        </div><!-- to_i-method -->
      
        <div id="to_int-method" class="method-detail ">
          <a name="method-i-to_int"></a>

          
          <div class="method-heading">
            <span class="method-name">to_int</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          
          <div>
  
            
            <p>Returns the value as an <a href="Integer.html"><code>Integer</code></a>.</p>

<p>If the <a href="BigDecimal.html"><code>BigDecimal</code></a> is infinity or NaN, raises FloatDomainError.</p>
            

            
            <div class="method-source-code" id="to_int-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
BigDecimal_to_i(VALUE self)
{
    ENTER(5);
    ssize_t e, nf;
    Real *p;

    GUARD_OBJ(p, GetVpValue(self, 1));
    BigDecimal_check_num(p);

    e = VpExponent10(p);
    if (e &lt;= 0) return INT2FIX(0);
    nf = VpBaseFig();
    if (e &lt;= nf) {
        return LONG2NUM((long)(VpGetSign(p) * (BDIGIT_DBL_SIGNED)p-&gt;frac[0]));
    }
    else {
        VALUE a = BigDecimal_split(self);
        VALUE digits = RARRAY_AREF(a, 1);
        VALUE numerator = rb_funcall(digits, rb_intern(&quot;to_i&quot;), 0);
        VALUE ret;
        ssize_t dpower = e - (ssize_t)RSTRING_LEN(digits);

        if (BIGDECIMAL_NEGATIVE_P(p)) {
            numerator = rb_funcall(numerator, &#39;*&#39;, 1, INT2FIX(-1));
        }
        if (dpower &lt; 0) {
            ret = rb_funcall(numerator, rb_intern(&quot;div&quot;), 1,
                              rb_funcall(INT2FIX(10), rb_intern(&quot;**&quot;), 1,
                                         INT2FIX(-dpower)));
        }
        else {
            ret = rb_funcall(numerator, &#39;*&#39;, 1,
                             rb_funcall(INT2FIX(10), rb_intern(&quot;**&quot;), 1,
                                        INT2FIX(dpower)));
        }
        if (RB_TYPE_P(ret, T_FLOAT)) {
            rb_raise(rb_eFloatDomainError, &quot;Infinity&quot;);
        }
        return ret;
    }
}
            </pre> 
            </div><!-- to_int-source -->
            
          </div>

          

          
        </div><!-- to_int-method -->
      
        <div id="to_r-method" class="method-detail ">
          <a name="method-i-to_r"></a>

          
          <div class="method-heading">
            <span class="method-name">to_r</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          
          <div>
  
            
            <p>Converts a <a href="BigDecimal.html"><code>BigDecimal</code></a> to a <a href="Rational.html"><code>Rational</code></a>.</p>
            

            
            <div class="method-source-code" id="to_r-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
BigDecimal_to_r(VALUE self)
{
    Real *p;
    ssize_t sign, power, denomi_power;
    VALUE a, digits, numerator;

    p = GetVpValue(self, 1);
    BigDecimal_check_num(p);

    sign = VpGetSign(p);
    power = VpExponent10(p);
    a = BigDecimal_split(self);
    digits = RARRAY_AREF(a, 1);
    denomi_power = power - RSTRING_LEN(digits);
    numerator = rb_funcall(digits, rb_intern(&quot;to_i&quot;), 0);

    if (sign &lt; 0) {
        numerator = rb_funcall(numerator, &#39;*&#39;, 1, INT2FIX(-1));
    }
    if (denomi_power &lt; 0) {
        return rb_Rational(numerator,
                           rb_funcall(INT2FIX(10), rb_intern(&quot;**&quot;), 1,
                                      INT2FIX(-denomi_power)));
    }
    else {
        return rb_Rational1(rb_funcall(numerator, &#39;*&#39;, 1,
                                       rb_funcall(INT2FIX(10), rb_intern(&quot;**&quot;), 1,
                                                  INT2FIX(denomi_power))));
    }
}
            </pre> 
            </div><!-- to_r-source -->
            
          </div>

          

          
        </div><!-- to_r-method -->
      
        <div id="to_s-method" class="method-detail ">
          <a name="method-i-to_s"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">to_s(s)</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Converts the value to a string.</p>

<p>The default format looks like  0.xxxxEnn.</p>

<p>The optional parameter s consists of either an integer; or an optional &#39;+&#39; or &#39; &#39;, followed by an optional number, followed by an optional &#39;E&#39; or &#39;F&#39;.</p>

<p>If there is a &#39;+&#39; at the start of s, positive values are returned with a leading &#39;+&#39;.</p>

<p>A space at the start of s returns positive values with a leading space.</p>

<p>If s contains a number, a space is inserted after each group of that many fractional digits.</p>

<p>If s ends with an &#39;E&#39;, engineering notation (0.xxxxEnn) is used.</p>

<p>If s ends with an &#39;F&#39;, conventional floating point notation is used.</p>

<p>Examples:</p>

<pre class="ruby"><span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&#39;-123.45678901234567890&#39;</span>).<span class="ruby-identifier">to_s</span>(<span class="ruby-string">&#39;5F&#39;</span>)
  <span class="ruby-comment">#=&gt; &#39;-123.45678 90123 45678 9&#39;</span>

<span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&#39;123.45678901234567890&#39;</span>).<span class="ruby-identifier">to_s</span>(<span class="ruby-string">&#39;+8F&#39;</span>)
  <span class="ruby-comment">#=&gt; &#39;+123.45678901 23456789&#39;</span>

<span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&#39;123.45678901234567890&#39;</span>).<span class="ruby-identifier">to_s</span>(<span class="ruby-string">&#39; F&#39;</span>)
  <span class="ruby-comment">#=&gt; &#39; 123.4567890123456789&#39;</span>
</pre>
            

            
            <div class="method-source-code" id="to_s-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
BigDecimal_to_s(int argc, VALUE *argv, VALUE self)
{
    ENTER(5);
    int   fmt = 0;   /* 0: E format, 1: F format */
    int   fPlus = 0; /* 0: default, 1: set &#39; &#39; before digits, 2: set &#39;+&#39; before digits. */
    Real  *vp;
    volatile VALUE str;
    char  *psz;
    char   ch;
    size_t nc, mc = 0;
    SIGNED_VALUE m;
    VALUE  f;

    GUARD_OBJ(vp, GetVpValue(self, 1));

    if (rb_scan_args(argc, argv, &quot;01&quot;, &amp;f) == 1) {
        if (RB_TYPE_P(f, T_STRING)) {
            psz = StringValueCStr(f);
            if (*psz == &#39; &#39;) {
                fPlus = 1;
                psz++;
            }
            else if (*psz == &#39;+&#39;) {
                fPlus = 2;
                psz++;
            }
            while ((ch = *psz++) != 0) {
                if (ISSPACE(ch)) {
                    continue;
                }
                if (!ISDIGIT(ch)) {
                    if (ch == &#39;F&#39; || ch == &#39;f&#39;) {
                        fmt = 1; /* F format */
                    }
                    break;
                }
                mc = mc*10 + ch - &#39;0&#39;;
            }
        }
        else {
            m = NUM2INT(f);
            if (m &lt;= 0) {
                rb_raise(rb_eArgError, &quot;argument must be positive&quot;);
            }
            mc = (size_t)m;
        }
    }
    if (fmt) {
        nc = VpNumOfChars(vp, &quot;F&quot;);
    }
    else {
        nc = VpNumOfChars(vp, &quot;E&quot;);
    }
    if (mc &gt; 0) {
        nc += (nc + mc - 1) / mc + 1;
    }

    str = rb_str_new(0, nc);
    psz = RSTRING_PTR(str);

    if (fmt) {
        VpToFString(vp, psz, mc, fPlus);
    }
    else {
        VpToString (vp, psz, mc, fPlus);
    }
    rb_str_resize(str, strlen(psz));
    return str;
}
            </pre> 
            </div><!-- to_s-source -->
            
          </div>

          

          
        </div><!-- to_s-method -->
      
        <div id="truncate-method" class="method-detail ">
          <a name="method-i-truncate"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">truncate(n)</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Truncate to the nearest integer (by default), returning the result as a <a href="BigDecimal.html"><code>BigDecimal</code></a>.</p>

<pre class="ruby"><span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&#39;3.14159&#39;</span>).<span class="ruby-identifier">truncate</span> <span class="ruby-comment">#=&gt; 3</span>
<span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&#39;8.7&#39;</span>).<span class="ruby-identifier">truncate</span> <span class="ruby-comment">#=&gt; 8</span>
<span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&#39;-9.9&#39;</span>).<span class="ruby-identifier">truncate</span> <span class="ruby-comment">#=&gt; -9</span>
</pre>

<p>If n is specified and positive, the fractional part of the result has no more than that many digits.</p>

<p>If n is specified and negative, at least that many digits to the left of the decimal point will be 0 in the result.</p>

<pre class="ruby"><span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&#39;3.14159&#39;</span>).<span class="ruby-identifier">truncate</span>(<span class="ruby-value">3</span>) <span class="ruby-comment">#=&gt; 3.141</span>
<span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&#39;13345.234&#39;</span>).<span class="ruby-identifier">truncate</span>(<span class="ruby-value">-2</span>) <span class="ruby-comment">#=&gt; 13300.0</span>
</pre>
            

            
            <div class="method-source-code" id="truncate-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
BigDecimal_truncate(int argc, VALUE *argv, VALUE self)
{
    ENTER(5);
    Real *c, *a;
    int iLoc;
    VALUE vLoc;
    size_t mx, pl = VpSetPrecLimit(0);

    if (rb_scan_args(argc, argv, &quot;01&quot;, &amp;vLoc) == 0) {
        iLoc = 0;
    }
    else {
        iLoc = NUM2INT(vLoc);
    }

    GUARD_OBJ(a, GetVpValue(self, 1));
    mx = a-&gt;Prec * (VpBaseFig() + 1);
    GUARD_OBJ(c, VpCreateRbObject(mx, &quot;0&quot;));
    VpSetPrecLimit(pl);
    VpActiveRound(c, a, VP_ROUND_DOWN, iLoc); /* 0: truncate */
    if (argc == 0) {
        return BigDecimal_to_i(ToValue(c));
    }
    return ToValue(c);
}
            </pre> 
            </div><!-- truncate-source -->
            
          </div>

          

          
        </div><!-- truncate-method -->
      
        <div id="zero-3F-method" class="method-detail ">
          <a name="method-i-zero-3F"></a>

          
          <div class="method-heading">
            <span class="method-name">zero?</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          
          <div>
  
            
            <p>Returns True if the value is zero.</p>
            

            
            <div class="method-source-code" id="zero-3F-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
BigDecimal_zero(VALUE self)
{
    Real *a = GetVpValue(self, 1);
    return VpIsZero(a) ? Qtrue : Qfalse;
}
            </pre> 
            </div><!-- zero-3F-source -->
            
          </div>

          

          
        </div><!-- zero-3F-method -->
      
      </div><!-- public-instance-method-details -->
    
    </div><!-- 5Buntitled-5D -->
  
  <div id='tx_BigDecimal_versioned' class='associated_wrapper'></div><script type='text/javascript'>$("#tx_BigDecimal_versioned").load("/associated/2.7.4/BigDecimal.ihtml");</script> <div id='tx_BigDecimal' class='associated_wrapper'></div><script type='text/javascript'>$("#tx_BigDecimal").load("/associated/BigDecimal.ihtml");</script> 
      
  </div><!-- documentation -->
  <div id='dynamic'>
  </div>
      
<div class='grids wrapper' id="footer">
  <p><small>This page was generated for Ruby 2.7.4</small></p> 
  
   <p><a href="http://ruby-doc.org">Ruby-doc.org</a> is a service of <a href="http://jamesbritt.com">James Britt</a> and <a href="http://neurogami.com">Neurogami</a>, purveyors of fine dance noise.  <div class='oio-inline'><ins data-revive-zoneid="1" data-revive-id="58924a5717c091dfee6dda3f7d38c4d7"></ins><script async src="//ras.ruby-doc.org/vvv/delivery/thesinkjs.php"></script></div></p>
 
       <p><small>Generated with Ruby-doc Rdoc Generator 0.42.0</small>.</p>
  </div>
</div>
  
 <script type='text/javascript'>
$(document).ready(function() {
      $.ajaxSetup({ cache: false });
      $("#vulns-alert").load("/associated/vulns.ihtml");
    });

    </script>


 
		<script type='text/javascript'>

	function loadPlus(plusdocs){
			$(plusdocs).find("div[class='associated_wrapper']").each (function() {
					$("#" + this.id).append($(plusdocs).find("#" + this.id ));
					});
	} 

   //function loadInline(json){
   // for (var lookFor in json) {
    //  $(lookFor).after(json[lookFor]);
    // }
  // } // end loadInline


$(document).ready(function() {
		$.ajaxSetup({ cache: false });
			$.get('/associated/2.7.4/plus_BigDecimal.ihtml', 
			function(plusdocs) {
			setTimeout(function() {
				loadPlus(plusdocs);
				}, 2000);
			}
			);


//     $.ajax({
//     dataType: "json",
//      url: '/associated/2.7.4/inline_BigDecimal.js',
//      success: function(json) {
// 			setTimeout(function() {
// 				loadInline(json);
// 				}, 2000);
// 			}
//    });

		});
</script>
		
</body>
</html>


