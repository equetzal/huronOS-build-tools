var search_data = {"index":{"searchIndex":["object","optionparser","ac","acceptables","ambiguousargument","ambiguousoption","arguable","completinghash","completion","invalidargument","invalidoption","list","missingargument","needlessargument","optionmap","parseerror","switch","noargument","optionalargument","placedargument","requiredargument","abort()","ac_arg_disable()","ac_arg_enable()","ac_arg_with()","accept()","accept()","accept()","additional_message()","append()","banner()","base()","candidate()","candidate()","candidate()","complete()","complete()","convert()","def_head_option()","def_option()","def_tail_option()","define()","define_by_keywords()","define_head()","define_tail()","each_const()","each_option()","environment()","extend_object()","filter_backtrace()","get_candidates()","getopts()","getopts()","getopts()","guess()","help()","inc()","inc()","incompatible_argument_styles()","incompatible_argument_styles()","inspect()","load()","make_switch()","match()","message()","new()","new()","new()","new()","new()","new()","on()","on_head()","on_tail()","options()","options=()","order()","order!()","order!()","parse()","parse()","parse()","parse()","parse()","parse!()","parse!()","pattern()","pattern()","permute()","permute!()","permute!()","prepend()","program_name()","reason()","recover()","regexp()","reject()","reject()","reject()","release()","remove()","search()","search_const()","separator()","set_backtrace()","set_option()","show_version()","summarize()","summarize()","summarize()","switch_name()","terminate()","terminate()","to_a()","to_s()","to_s()","top()","top()","ver()","version()","warn()","with()"],"longSearchIndex":["object","optionparser","optionparser::ac","optionparser::acceptables","optionparser::ambiguousargument","optionparser::ambiguousoption","optionparser::arguable","optionparser::completinghash","optionparser::completion","optionparser::invalidargument","optionparser::invalidoption","optionparser::list","optionparser::missingargument","optionparser::needlessargument","optionparser::optionmap","optionparser::parseerror","optionparser::switch","optionparser::switch::noargument","optionparser::switch::optionalargument","optionparser::switch::placedargument","optionparser::switch::requiredargument","optionparser#abort()","optionparser::ac#ac_arg_disable()","optionparser::ac#ac_arg_enable()","optionparser::ac#ac_arg_with()","optionparser#accept()","optionparser::accept()","optionparser::list#accept()","optionparser#additional_message()","optionparser::list#append()","optionparser#banner()","optionparser#base()","optionparser#candidate()","optionparser::completion::candidate()","optionparser::completion#candidate()","optionparser::completion#complete()","optionparser::list#complete()","optionparser::completion#convert()","optionparser#def_head_option()","optionparser#def_option()","optionparser#def_tail_option()","optionparser#define()","optionparser#define_by_keywords()","optionparser#define_head()","optionparser#define_tail()","optionparser::each_const()","optionparser::list#each_option()","optionparser#environment()","optionparser::arguable::extend_object()","optionparser::parseerror::filter_backtrace()","optionparser::list#get_candidates()","optionparser#getopts()","optionparser::getopts()","optionparser::arguable#getopts()","optionparser::switch::guess()","optionparser#help()","optionparser::inc()","optionparser#inc()","optionparser::switch::incompatible_argument_styles()","optionparser::switch::noargument::incompatible_argument_styles()","optionparser::parseerror#inspect()","optionparser#load()","optionparser#make_switch()","optionparser::completinghash#match()","optionparser::parseerror#message()","optionparser::new()","optionparser#new()","optionparser::arguable::new()","optionparser::list::new()","optionparser::parseerror::new()","optionparser::switch::new()","optionparser#on()","optionparser#on_head()","optionparser#on_tail()","optionparser::arguable#options()","optionparser::arguable#options=()","optionparser#order()","optionparser#order!()","optionparser::arguable#order!()","optionparser#parse()","optionparser::switch::noargument#parse()","optionparser::switch::optionalargument#parse()","optionparser::switch::placedargument#parse()","optionparser::switch::requiredargument#parse()","optionparser#parse!()","optionparser::arguable#parse!()","optionparser::switch::pattern()","optionparser::switch::noargument::pattern()","optionparser#permute()","optionparser#permute!()","optionparser::arguable#permute!()","optionparser::list#prepend()","optionparser#program_name()","optionparser::parseerror#reason()","optionparser::parseerror#recover()","optionparser::completion::regexp()","optionparser#reject()","optionparser::reject()","optionparser::list#reject()","optionparser#release()","optionparser#remove()","optionparser::list#search()","optionparser::search_const()","optionparser#separator()","optionparser::parseerror#set_backtrace()","optionparser::parseerror#set_option()","optionparser::show_version()","optionparser#summarize()","optionparser::list#summarize()","optionparser::switch#summarize()","optionparser::switch#switch_name()","optionparser#terminate()","optionparser::terminate()","optionparser#to_a()","optionparser#to_s()","optionparser::parseerror#to_s()","optionparser::top()","optionparser#top()","optionparser#ver()","optionparser#version()","optionparser#warn()","optionparser::with()"],"info":[["Object","","Object.html","",""],["OptionParser","","OptionParser.html","","<p>OptionParser\n<p>Introduction\n<p>OptionParser is a class for command-line option analysis.  It is much more advanced, …\n"],["OptionParser::AC","","OptionParser/AC.html","",""],["OptionParser::Acceptables","","OptionParser/Acceptables.html","","<p>Acceptable argument classes. Now contains DecimalInteger, OctalInteger and DecimalNumeric. See Acceptable …\n"],["OptionParser::AmbiguousArgument","","OptionParser/AmbiguousArgument.html","","<p>Raises when the given argument word can&#39;t be completed uniquely.\n"],["OptionParser::AmbiguousOption","","OptionParser/AmbiguousOption.html","","<p>Raises when ambiguously completable string is encountered.\n"],["OptionParser::Arguable","","OptionParser/Arguable.html","","<p>Extends command line arguments array (ARGV) to parse itself.\n"],["OptionParser::CompletingHash","","OptionParser/CompletingHash.html","","<p>Hash with completion search feature. See OptionParser::Completion.\n"],["OptionParser::Completion","","OptionParser/Completion.html","","<p>Keyword completion module.  This allows partial arguments to be specified and resolved against a list …\n"],["OptionParser::InvalidArgument","","OptionParser/InvalidArgument.html","","<p>Raises when the given argument does not match required format.\n"],["OptionParser::InvalidOption","","OptionParser/InvalidOption.html","","<p>Raises when switch is undefined.\n"],["OptionParser::List","","OptionParser/List.html","","<p>Simple option list providing mapping from short and/or long option string to OptionParser::Switch and …\n"],["OptionParser::MissingArgument","","OptionParser/MissingArgument.html","","<p>Raises when a switch with mandatory argument has no argument.\n"],["OptionParser::NeedlessArgument","","OptionParser/NeedlessArgument.html","","<p>Raises when there is an argument for a switch which takes no argument.\n"],["OptionParser::OptionMap","","OptionParser/OptionMap.html","","<p>Map from option/keyword string to object with completion.\n"],["OptionParser::ParseError","","OptionParser/ParseError.html","","<p>Base class of exceptions from OptionParser.\n"],["OptionParser::Switch","","OptionParser/Switch.html","","<p>Individual switch class.  Not important to the user.\n<p>Defined within Switch are several Switch-derived …\n"],["OptionParser::Switch::NoArgument","","OptionParser/Switch/NoArgument.html","","<p>Switch that takes no arguments.\n"],["OptionParser::Switch::OptionalArgument","","OptionParser/Switch/OptionalArgument.html","","<p>Switch that can omit argument.\n"],["OptionParser::Switch::PlacedArgument","","OptionParser/Switch/PlacedArgument.html","","<p>Switch that takes an argument, which does not begin with &#39;-&#39;.\n"],["OptionParser::Switch::RequiredArgument","","OptionParser/Switch/RequiredArgument.html","","<p>Switch that takes an argument.\n"],["abort","OptionParser","OptionParser.html#method-i-abort","(mesg = $!)",""],["ac_arg_disable","OptionParser::AC","OptionParser/AC.html#method-i-ac_arg_disable","(name, help_string, &block)",""],["ac_arg_enable","OptionParser::AC","OptionParser/AC.html#method-i-ac_arg_enable","(name, help_string, &block)",""],["ac_arg_with","OptionParser::AC","OptionParser/AC.html#method-i-ac_arg_with","(name, help_string, &block)",""],["accept","OptionParser","OptionParser.html#method-i-accept","(*args, &blk)","<p>Directs to accept specified class <code>t</code>. The argument string is passed to the block in which it should be …\n"],["accept","OptionParser","OptionParser.html#method-c-accept","(*args, &blk)","<p>See #accept.\n"],["accept","OptionParser::List","OptionParser/List.html#method-i-accept","(t, pat = /.*/m, &block)","<p>See OptionParser.accept.\n"],["additional_message","OptionParser","OptionParser.html#method-i-additional_message","(typ, opt)","<p>Returns additional info.\n"],["append","OptionParser::List","OptionParser/List.html#method-i-append","(*args)","<p>Appends <code>switch</code> at the tail of the list, and associates short, long and negated long options. Arguments …\n"],["banner","OptionParser","OptionParser.html#method-i-banner","()","<p>Heading banner preceding summary.\n"],["base","OptionParser","OptionParser.html#method-i-base","()","<p>Subject of #on_tail.\n"],["candidate","OptionParser","OptionParser.html#method-i-candidate","(word)",""],["candidate","OptionParser::Completion","OptionParser/Completion.html#method-c-candidate","(key, icase = false, pat = nil, &block)",""],["candidate","OptionParser::Completion","OptionParser/Completion.html#method-i-candidate","(key, icase = false, pat = nil)",""],["complete","OptionParser::Completion","OptionParser/Completion.html#method-i-complete","(key, icase = false, pat = nil)",""],["complete","OptionParser::List","OptionParser/List.html#method-i-complete","(id, opt, icase = false, *pat, &block)","<p>Searches list <code>id</code> for <code>opt</code> and the optional patterns for completion <code>pat</code>. If <code>icase</code> is true, the search is …\n"],["convert","OptionParser::Completion","OptionParser/Completion.html#method-i-convert","(opt = nil, val = nil, *)",""],["def_head_option","OptionParser","OptionParser.html#method-i-def_head_option","(*opts, &block)",""],["def_option","OptionParser","OptionParser.html#method-i-def_option","(*opts, &block)",""],["def_tail_option","OptionParser","OptionParser.html#method-i-def_tail_option","(*opts, &block)",""],["define","OptionParser","OptionParser.html#method-i-define","(*opts, &block)",""],["define_by_keywords","OptionParser","OptionParser.html#method-i-define_by_keywords","(options, meth, **opts)",""],["define_head","OptionParser","OptionParser.html#method-i-define_head","(*opts, &block)",""],["define_tail","OptionParser","OptionParser.html#method-i-define_tail","(*opts, &block)",""],["each_const","OptionParser","OptionParser.html#method-c-each_const","(path, base = ::Object)",""],["each_option","OptionParser::List","OptionParser/List.html#method-i-each_option","(&block)","<p>Iterates over each option, passing the option to the <code>block</code>.\n"],["environment","OptionParser","OptionParser.html#method-i-environment","(env = File.basename($0, '.*'))","<p>Parses environment variable <code>env</code> or its uppercase with splitting like a shell.\n<p><code>env</code> defaults to the basename …\n"],["extend_object","OptionParser::Arguable","OptionParser/Arguable.html#method-c-extend_object","(obj)","<p>Initializes instance variable.\n"],["filter_backtrace","OptionParser::ParseError","OptionParser/ParseError.html#method-c-filter_backtrace","(array)",""],["get_candidates","OptionParser::List","OptionParser/List.html#method-i-get_candidates","(id)",""],["getopts","OptionParser","OptionParser.html#method-i-getopts","(*args)","<p>Wrapper method for getopts.rb.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">params</span> = <span class=\"ruby-constant\">ARGV</span>.<span class=\"ruby-identifier\">getopts</span>(<span class=\"ruby-string\">&quot;ab:&quot;</span>, <span class=\"ruby-string\">&quot;foo&quot;</span>, <span class=\"ruby-string\">&quot;bar:&quot;</span>, <span class=\"ruby-string\">&quot;zot:Z;zot option&quot;</span>)\n<span class=\"ruby-comment\"># params[&quot;a&quot;] ...</span>\n</pre>\n"],["getopts","OptionParser","OptionParser.html#method-c-getopts","(*args)","<p>See #getopts.\n"],["getopts","OptionParser::Arguable","OptionParser/Arguable.html#method-i-getopts","(*args)","<p>Substitution of getopts is possible as follows. Also see OptionParser#getopts.\n\n<pre>def getopts(*args)\n  ($OPT ...</pre>\n"],["guess","OptionParser::Switch","OptionParser/Switch.html#method-c-guess","(arg)","<p>Guesses argument style from <code>arg</code>.  Returns corresponding OptionParser::Switch class (OptionalArgument …\n"],["help","OptionParser","OptionParser.html#method-i-help","()","<p>Returns option summary string.\n"],["inc","OptionParser","OptionParser.html#method-c-inc","(arg, default = nil)","<p>Returns an incremented value of <code>default</code> according to <code>arg</code>.\n"],["inc","OptionParser","OptionParser.html#method-i-inc","(*args)",""],["incompatible_argument_styles","OptionParser::Switch","OptionParser/Switch.html#method-c-incompatible_argument_styles","(arg, t)",""],["incompatible_argument_styles","OptionParser::Switch::NoArgument","OptionParser/Switch/NoArgument.html#method-c-incompatible_argument_styles","(*)",""],["inspect","OptionParser::ParseError","OptionParser/ParseError.html#method-i-inspect","()",""],["load","OptionParser","OptionParser.html#method-i-load","(filename = nil)","<p>Loads options from file names as <code>filename</code>. Does nothing when the file is not present. Returns whether …\n"],["make_switch","OptionParser","OptionParser.html#method-i-make_switch","(opts, block = nil)","<p>Creates an OptionParser::Switch from the parameters. The parsed argument value is passed to the given …\n"],["match","OptionParser::CompletingHash","OptionParser/CompletingHash.html#method-i-match","(key)","<p>Completion for hash key.\n"],["message","OptionParser::ParseError","OptionParser/ParseError.html#method-i-message","()","<p>Default stringizing method to emit standard error message.\n"],["new","OptionParser","OptionParser.html#method-c-new","(banner = nil, width = 32, indent = ' ' * 4)","<p>Initializes the instance and yields itself if called with a block.\n<p><code>banner</code> &mdash; Banner message.\n<p><code>width</code> &mdash; Summary …\n"],["new","OptionParser","OptionParser.html#method-i-new","()","<p>Pushes a new List.\n"],["new","OptionParser::Arguable","OptionParser/Arguable.html#method-c-new","(*args)",""],["new","OptionParser::List","OptionParser/List.html#method-c-new","()","<p>Just initializes all instance variables.\n"],["new","OptionParser::ParseError","OptionParser/ParseError.html#method-c-new","(*args, additional: nil)",""],["new","OptionParser::Switch","OptionParser/Switch.html#method-c-new","(pattern = nil, conv = nil, short = nil, long = nil, arg = nil, desc = ([] if short or long), block = nil, &_block)",""],["on","OptionParser","OptionParser.html#method-i-on","(*opts, &block)","<p>Add option switch and handler. See #make_switch for an explanation of parameters.\n"],["on_head","OptionParser","OptionParser.html#method-i-on_head","(*opts, &block)","<p>Add option switch like with #on, but at head of summary.\n"],["on_tail","OptionParser","OptionParser.html#method-i-on_tail","(*opts, &block)","<p>Add option switch like with #on, but at tail of summary.\n"],["options","OptionParser::Arguable","OptionParser/Arguable.html#method-i-options","()","<p>Actual OptionParser object, automatically created if nonexistent.\n<p>If called with a block, yields the  …\n"],["options=","OptionParser::Arguable","OptionParser/Arguable.html#method-i-options-3D","(opt)","<p>Sets OptionParser object, when <code>opt</code> is <code>false</code> or <code>nil</code>, methods OptionParser::Arguable#options and OptionParser::Arguable#options= …\n"],["order","OptionParser","OptionParser.html#method-i-order","(*argv, into: nil, &nonopt)","<p>Parses command line arguments <code>argv</code> in order. When a block is given, each non-option argument is yielded. …\n"],["order!","OptionParser","OptionParser.html#method-i-order-21","(argv = default_argv, into: nil, &nonopt)","<p>Same as #order, but removes switches destructively. Non-option arguments remain in <code>argv</code>.\n"],["order!","OptionParser::Arguable","OptionParser/Arguable.html#method-i-order-21","(&blk)","<p>Parses <code>self</code> destructively in order and returns <code>self</code> containing the rest arguments left unparsed.\n"],["parse","OptionParser","OptionParser.html#method-i-parse","(*argv, into: nil)","<p>Parses command line arguments <code>argv</code> in order when environment variable POSIXLY_CORRECT is set, and in …\n"],["parse","OptionParser::Switch::NoArgument","OptionParser/Switch/NoArgument.html#method-i-parse","(arg, argv)","<p>Raises an exception if any arguments given.\n"],["parse","OptionParser::Switch::OptionalArgument","OptionParser/Switch/OptionalArgument.html#method-i-parse","(arg, argv, &error)","<p>Parses argument if given, or uses default value.\n"],["parse","OptionParser::Switch::PlacedArgument","OptionParser/Switch/PlacedArgument.html#method-i-parse","(arg, argv, &error)","<p>Returns nil if argument is not present or begins with &#39;-&#39;.\n"],["parse","OptionParser::Switch::RequiredArgument","OptionParser/Switch/RequiredArgument.html#method-i-parse","(arg, argv)","<p>Raises an exception if argument is not present.\n"],["parse!","OptionParser","OptionParser.html#method-i-parse-21","(argv = default_argv, into: nil)","<p>Same as #parse, but removes switches destructively. Non-option arguments remain in <code>argv</code>.\n"],["parse!","OptionParser::Arguable","OptionParser/Arguable.html#method-i-parse-21","()","<p>Parses <code>self</code> destructively and returns <code>self</code> containing the rest arguments left unparsed.\n"],["pattern","OptionParser::Switch","OptionParser/Switch.html#method-c-pattern","()",""],["pattern","OptionParser::Switch::NoArgument","OptionParser/Switch/NoArgument.html#method-c-pattern","()",""],["permute","OptionParser","OptionParser.html#method-i-permute","(*argv, into: nil)","<p>Parses command line arguments <code>argv</code> in permutation mode and returns list of non-option arguments. When …\n"],["permute!","OptionParser","OptionParser.html#method-i-permute-21","(argv = default_argv, into: nil)","<p>Same as #permute, but removes switches destructively. Non-option arguments remain in <code>argv</code>.\n"],["permute!","OptionParser::Arguable","OptionParser/Arguable.html#method-i-permute-21","()","<p>Parses <code>self</code> destructively in permutation mode and returns <code>self</code> containing the rest arguments left unparsed. …\n"],["prepend","OptionParser::List","OptionParser/List.html#method-i-prepend","(*args)","<p>Inserts <code>switch</code> at the head of the list, and associates short, long and negated long options. Arguments …\n"],["program_name","OptionParser","OptionParser.html#method-i-program_name","()","<p>Program name to be emitted in error message and default banner, defaults to $0.\n"],["reason","OptionParser::ParseError","OptionParser/ParseError.html#method-i-reason","()","<p>Returns error reason. Override this for I18N.\n"],["recover","OptionParser::ParseError","OptionParser/ParseError.html#method-i-recover","(argv)","<p>Pushes back erred argument(s) to <code>argv</code>.\n"],["regexp","OptionParser::Completion","OptionParser/Completion.html#method-c-regexp","(key, icase)",""],["reject","OptionParser","OptionParser.html#method-i-reject","(*args, &blk)","<p>Directs to reject specified class argument.\n<p><code>t</code> &mdash; Argument class specifier, any object including Class.\n\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">reject</span>(<span class=\"ruby-identifier\">t</span>)\n</pre>\n"],["reject","OptionParser","OptionParser.html#method-c-reject","(*args, &blk)","<p>See #reject.\n"],["reject","OptionParser::List","OptionParser/List.html#method-i-reject","(t)","<p>See OptionParser.reject.\n"],["release","OptionParser","OptionParser.html#method-i-release","()","<p>Release code\n"],["remove","OptionParser","OptionParser.html#method-i-remove","()","<p>Removes the last List.\n"],["search","OptionParser::List","OptionParser/List.html#method-i-search","(id, key)","<p>Searches <code>key</code> in <code>id</code> list. The result is returned or yielded if a block is given. If it isn&#39;t found, …\n"],["search_const","OptionParser","OptionParser.html#method-c-search_const","(klass, name)",""],["separator","OptionParser","OptionParser.html#method-i-separator","(string)","<p>Add separator in summary.\n"],["set_backtrace","OptionParser::ParseError","OptionParser/ParseError.html#method-i-set_backtrace","(array)",""],["set_option","OptionParser::ParseError","OptionParser/ParseError.html#method-i-set_option","(opt, eq)",""],["show_version","OptionParser","OptionParser.html#method-c-show_version","(*pkgs)",""],["summarize","OptionParser","OptionParser.html#method-i-summarize","(to = [], width = @summary_width, max = width - 1, indent = @summary_indent, &blk)","<p>Puts option summary into <code>to</code> and returns <code>to</code>. Yields each line if a block is given.\n<p><code>to</code> &mdash; Output destination, …\n"],["summarize","OptionParser::List","OptionParser/List.html#method-i-summarize","(*args, &block)","<p>Creates the summary table, passing each line to the <code>block</code> (without newline). The arguments <code>args</code> are passed …\n"],["summarize","OptionParser::Switch","OptionParser/Switch.html#method-i-summarize","(sdone = {}, ldone = {}, width = 1, max = width - 1, indent = \"\")","<p>Produces the summary text. Each line of the summary is yielded to the block (without newline).\n<p><code>sdone</code> &mdash; "],["switch_name","OptionParser::Switch","OptionParser/Switch.html#method-i-switch_name","()","<p>Main name of the switch.\n"],["terminate","OptionParser","OptionParser.html#method-i-terminate","(arg = nil)","<p>Terminates option parsing. Optional parameter <code>arg</code> is a string pushed back to be the first non-option …\n"],["terminate","OptionParser","OptionParser.html#method-c-terminate","(arg = nil)",""],["to_a","OptionParser","OptionParser.html#method-i-to_a","()","<p>Returns option summary list.\n"],["to_s","OptionParser","OptionParser.html#method-i-to_s","()",""],["to_s","OptionParser::ParseError","OptionParser/ParseError.html#method-i-to_s","()",""],["top","OptionParser","OptionParser.html#method-c-top","()",""],["top","OptionParser","OptionParser.html#method-i-top","()","<p>Subject of #on / #on_head, #accept / #reject\n"],["ver","OptionParser","OptionParser.html#method-i-ver","()","<p>Returns version string from program_name, version and release.\n"],["version","OptionParser","OptionParser.html#method-i-version","()","<p>Version\n"],["warn","OptionParser","OptionParser.html#method-i-warn","(mesg = $!)",""],["with","OptionParser","OptionParser.html#method-c-with","(*args, &block)","<p>Initializes a new instance and evaluates the optional block in context of the instance. Arguments <code>args</code> …\n"]]}}